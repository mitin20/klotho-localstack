"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToJsonFunction = void 0;
class ToJsonFunction {
    constructor(baseType) {
        this.baseType = baseType;
        this.fields = {};
        this.functionName = `toJson_${baseType}`;
    }
    /**
     * Adds a field to the struct.
     *
     * @param schemaName The name of the property in the schema ("to")
     * @param propertyName The name of the TypeScript property ("from")
     * @param toJson A function used to convert a value from JavaScript to schema
     * format. This could be `x => x` if no conversion is required.
     */
    addField(schemaName, propertyName, toJson) {
        this.fields[schemaName] = toJson(`obj.${propertyName}`);
    }
    emit(code) {
        code.line();
        code.line('/**');
        code.line(` * Converts an object of type '${this.baseType}' to JSON representation.`);
        code.line(' */');
        code.line('/* eslint-disable max-len, quote-props */');
        code.openBlock(`export function ${this.functionName}(obj: ${this.baseType} | undefined): Record<string, any> | undefined`);
        code.line('if (obj === undefined) { return undefined; }');
        code.open('const result = {');
        for (const [k, v] of Object.entries(this.fields)) {
            code.line(`'${k}': ${v},`);
        }
        code.close('};');
        code.line('// filter undefined values');
        code.line('return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});');
        code.closeBlock();
        code.line('/* eslint-enable max-len, quote-props */');
    }
}
exports.ToJsonFunction = ToJsonFunction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9qc29uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3RvanNvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFFQSxNQUFhLGNBQWM7SUFRekIsWUFBNkIsUUFBZ0I7UUFBaEIsYUFBUSxHQUFSLFFBQVEsQ0FBUTtRQUY1QixXQUFNLEdBQTJCLEVBQUUsQ0FBQztRQUduRCxJQUFJLENBQUMsWUFBWSxHQUFHLFVBQVUsUUFBUSxFQUFFLENBQUM7SUFDM0MsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxRQUFRLENBQUMsVUFBa0IsRUFBRSxZQUFvQixFQUFFLE1BQWM7UUFDdEUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsR0FBRyxNQUFNLENBQUMsT0FBTyxZQUFZLEVBQUUsQ0FBQyxDQUFDO0lBQzFELENBQUM7SUFFTSxJQUFJLENBQUMsSUFBVTtRQUNwQixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDWixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2pCLElBQUksQ0FBQyxJQUFJLENBQUMsa0NBQWtDLElBQUksQ0FBQyxRQUFRLDJCQUEyQixDQUFDLENBQUM7UUFDdEYsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDLDJDQUEyQyxDQUFDLENBQUM7UUFDdkQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxtQkFBbUIsSUFBSSxDQUFDLFlBQVksU0FBUyxJQUFJLENBQUMsUUFBUSxnREFBZ0QsQ0FBQyxDQUFDO1FBQzNILElBQUksQ0FBQyxJQUFJLENBQUMsOENBQThDLENBQUMsQ0FBQztRQUUxRCxJQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFDOUIsS0FBSyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2hELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUM1QjtRQUNELElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFakIsSUFBSSxDQUFDLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxJQUFJLENBQUMsMEdBQTBHLENBQUMsQ0FBQztRQUV0SCxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDO0lBQ3hELENBQUM7Q0FDRjtBQTdDRCx3Q0E2Q0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2RlIH0gZnJvbSAnLi9jb2RlJztcblxuZXhwb3J0IGNsYXNzIFRvSnNvbkZ1bmN0aW9uIHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIHRoZSB0b0pzb24gZnVuY3Rpb24gZm9yIGEgc3RydWN0LlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGZ1bmN0aW9uTmFtZTogc3RyaW5nO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgZmllbGRzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBiYXNlVHlwZTogc3RyaW5nKSB7XG4gICAgdGhpcy5mdW5jdGlvbk5hbWUgPSBgdG9Kc29uXyR7YmFzZVR5cGV9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgZmllbGQgdG8gdGhlIHN0cnVjdC5cbiAgICpcbiAgICogQHBhcmFtIHNjaGVtYU5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IGluIHRoZSBzY2hlbWEgKFwidG9cIilcbiAgICogQHBhcmFtIHByb3BlcnR5TmFtZSBUaGUgbmFtZSBvZiB0aGUgVHlwZVNjcmlwdCBwcm9wZXJ0eSAoXCJmcm9tXCIpXG4gICAqIEBwYXJhbSB0b0pzb24gQSBmdW5jdGlvbiB1c2VkIHRvIGNvbnZlcnQgYSB2YWx1ZSBmcm9tIEphdmFTY3JpcHQgdG8gc2NoZW1hXG4gICAqIGZvcm1hdC4gVGhpcyBjb3VsZCBiZSBgeCA9PiB4YCBpZiBubyBjb252ZXJzaW9uIGlzIHJlcXVpcmVkLlxuICAgKi9cbiAgcHVibGljIGFkZEZpZWxkKHNjaGVtYU5hbWU6IHN0cmluZywgcHJvcGVydHlOYW1lOiBzdHJpbmcsIHRvSnNvbjogVG9Kc29uKSB7XG4gICAgdGhpcy5maWVsZHNbc2NoZW1hTmFtZV0gPSB0b0pzb24oYG9iai4ke3Byb3BlcnR5TmFtZX1gKTtcbiAgfVxuXG4gIHB1YmxpYyBlbWl0KGNvZGU6IENvZGUpIHtcbiAgICBjb2RlLmxpbmUoKTtcbiAgICBjb2RlLmxpbmUoJy8qKicpO1xuICAgIGNvZGUubGluZShgICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgJyR7dGhpcy5iYXNlVHlwZX0nIHRvIEpTT04gcmVwcmVzZW50YXRpb24uYCk7XG4gICAgY29kZS5saW5lKCcgKi8nKTtcbiAgICBjb2RlLmxpbmUoJy8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIHF1b3RlLXByb3BzICovJyk7XG4gICAgY29kZS5vcGVuQmxvY2soYGV4cG9ydCBmdW5jdGlvbiAke3RoaXMuZnVuY3Rpb25OYW1lfShvYmo6ICR7dGhpcy5iYXNlVHlwZX0gfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkYCk7XG4gICAgY29kZS5saW5lKCdpZiAob2JqID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfScpO1xuXG4gICAgY29kZS5vcGVuKCdjb25zdCByZXN1bHQgPSB7Jyk7XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5maWVsZHMpKSB7XG4gICAgICBjb2RlLmxpbmUoYCcke2t9JzogJHt2fSxgKTtcbiAgICB9XG4gICAgY29kZS5jbG9zZSgnfTsnKTtcblxuICAgIGNvZGUubGluZSgnLy8gZmlsdGVyIHVuZGVmaW5lZCB2YWx1ZXMnKTtcbiAgICBjb2RlLmxpbmUoJ3JldHVybiBPYmplY3QuZW50cmllcyhyZXN1bHQpLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiBpWzFdIH0pLCB7fSk7Jyk7XG5cbiAgICBjb2RlLmNsb3NlQmxvY2soKTtcbiAgICBjb2RlLmxpbmUoJy8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgcXVvdGUtcHJvcHMgKi8nKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyBhbiBleHByZXNzaW9uIGZyb20gSmF2YVNjcmlwdCB0byBzY2hlbWEgZm9ybWF0LlxuICpcbiAqIEBleGFtcGxlIHggPT4geFxuICogQGV4YW1wbGUgeCA9PiB4Py5tYXAoeSA9PiB0b0pzb25fRm9vKHkpKVxuICovXG5leHBvcnQgdHlwZSBUb0pzb24gPSAoZXhwcmVzc2lvbjogc3RyaW5nKSA9PiBzdHJpbmc7XG4iXX0=