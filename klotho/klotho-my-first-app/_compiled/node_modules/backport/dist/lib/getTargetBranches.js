"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTargetBranchChoices = exports.getTargetBranches = void 0;
const lodash_1 = require("lodash");
const BackportError_1 = require("./BackportError");
const prompts_1 = require("./prompts");
async function getTargetBranches(options, commits) {
    // target branches already specified (in contrast to letting the user choose from a list)
    if (!(0, lodash_1.isEmpty)(options.targetBranches)) {
        return options.targetBranches;
    }
    // target branches from the first commit
    const suggestedTargetBranches = commits.length === 1 ? commits[0].suggestedTargetBranches : [];
    // require target branches to be specified when when in non-interactive mode
    if (!options.interactive) {
        if ((0, lodash_1.isEmpty)(suggestedTargetBranches)) {
            throw new BackportError_1.BackportError({ code: 'no-branches-exception' });
        }
        return suggestedTargetBranches;
    }
    // sourceBranch should be the same for all commits, so picking `sourceBranch` from the first commit should be fine ðŸ¤ž
    // this is specifically needed when backporting a PR like `backport --pr 123` and the source PR was merged to a non-default (aka non-master) branch.
    const { sourceBranch } = commits[0];
    const targetBranchChoices = getTargetBranchChoices(options, suggestedTargetBranches, sourceBranch);
    // render prmompt for selecting target branches
    return (0, prompts_1.promptForTargetBranches)({
        targetBranchChoices,
        isMultipleChoice: options.multipleBranches,
    });
}
exports.getTargetBranches = getTargetBranches;
function getTargetBranchChoices(options, suggestedTargetBranches, sourceBranch) {
    // exclude sourceBranch from targetBranchChoices
    const targetBranchesChoices = getTargetBranchChoicesAsObject(options.targetBranchChoices).filter((choice) => choice.name !== sourceBranch);
    if ((0, lodash_1.isEmpty)(targetBranchesChoices)) {
        throw new BackportError_1.BackportError('Missing target branch choices');
    }
    if (!options.branchLabelMapping) {
        return targetBranchesChoices;
    }
    // select missing target branches (based on pull request labels)
    return targetBranchesChoices.map((choice) => {
        const isChecked = suggestedTargetBranches.includes(choice.name);
        return { ...choice, checked: isChecked };
    });
}
exports.getTargetBranchChoices = getTargetBranchChoices;
// `targetBranchChoices` can either be a string or an object.
// It must be transformed so it is always treated as an object troughout the application
function getTargetBranchChoicesAsObject(targetBranchChoices) {
    if (!targetBranchChoices) {
        return [];
    }
    return targetBranchChoices.map((choice) => {
        if ((0, lodash_1.isString)(choice)) {
            return {
                name: choice,
                checked: false,
            };
        }
        return choice;
    });
}
