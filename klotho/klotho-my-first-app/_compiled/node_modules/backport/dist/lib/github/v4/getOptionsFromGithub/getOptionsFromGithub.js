"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOptionsFromGithub = void 0;
const BackportError_1 = require("../../../BackportError");
const git_1 = require("../../../git");
const logger_1 = require("../../../logger");
const remoteConfig_1 = require("../../../remoteConfig");
const apiRequestV4_1 = require("../apiRequestV4");
const throwOnInvalidAccessToken_1 = require("../throwOnInvalidAccessToken");
const query_1 = require("./query");
async function getOptionsFromGithub(options) {
    const { accessToken, githubApiBaseUrlV4, repoName, repoOwner, globalConfigFile, } = options;
    let res;
    try {
        res = await (0, apiRequestV4_1.apiRequestV4)({
            githubApiBaseUrlV4,
            accessToken,
            query: query_1.query,
            variables: { repoOwner, repoName },
        });
    }
    catch (e) {
        if (!(e instanceof apiRequestV4_1.GithubV4Exception)) {
            throw e;
        }
        (0, throwOnInvalidAccessToken_1.throwOnInvalidAccessToken)({
            error: e,
            repoName,
            repoOwner,
            globalConfigFile,
        });
        res = (0, remoteConfig_1.swallowMissingConfigFileException)(e);
    }
    // it is not possible to have a branch named "backport"
    if (res.repository.illegalBackportBranch) {
        throw new BackportError_1.BackportError('You must delete the branch "backport" to continue. See https://github.com/sqren/backport/issues/155 for details');
    }
    const remoteConfig = await getRemoteConfigFileOptions(res, options.cwd, options.skipRemoteConfig);
    return {
        authenticatedUsername: res.viewer.login,
        sourceBranch: res.repository.defaultBranchRef.name,
        isRepoPrivate: res.repository.isPrivate,
        ...remoteConfig,
    };
}
exports.getOptionsFromGithub = getOptionsFromGithub;
async function getRemoteConfigFileOptions(res, cwd, skipRemoteConfig) {
    if (skipRemoteConfig) {
        logger_1.logger.info('Skipping remote config: `--skip-remote-config` specified via config file or cli');
        return;
    }
    const remoteConfig = res.repository.defaultBranchRef.target.remoteConfigHistory.edges?.[0]
        ?.remoteConfig;
    if (!remoteConfig) {
        logger_1.logger.info("Skipping remote config: remote config doesn't exist");
        return;
    }
    if (cwd) {
        const [isLocalConfigModified, isLocalConfigUntracked, localCommitDate] = await Promise.all([
            (0, git_1.isLocalConfigFileModified)({ cwd }),
            (0, git_1.isLocalConfigFileUntracked)({ cwd }),
            (0, git_1.getLocalConfigFileCommitDate)({ cwd }),
        ]);
        if (isLocalConfigUntracked) {
            logger_1.logger.info('Skipping remote config: local config is new');
            return;
        }
        if (isLocalConfigModified) {
            logger_1.logger.info('Skipping remote config: local config is modified');
            return;
        }
        if (localCommitDate &&
            localCommitDate > Date.parse(remoteConfig.committedDate)) {
            logger_1.logger.info(`Skipping remote config: local config is newer: ${new Date(localCommitDate).toISOString()} > ${remoteConfig.committedDate}`);
            return;
        }
    }
    return (0, remoteConfig_1.parseRemoteConfig)(remoteConfig);
}
