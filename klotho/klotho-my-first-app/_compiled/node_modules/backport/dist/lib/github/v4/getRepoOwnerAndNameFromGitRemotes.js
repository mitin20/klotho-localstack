"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRepoOwnerAndNameFromGitRemotes = void 0;
const graphql_tag_1 = __importDefault(require("graphql-tag"));
const maybe_1 = require("../../../utils/maybe");
const git_1 = require("../../git");
const logger_1 = require("../../logger");
const apiRequestV4_1 = require("./apiRequestV4");
// This method should be used to get the origin owner (instead of a fork owner)
async function getRepoOwnerAndNameFromGitRemotes({ accessToken, githubApiBaseUrlV4, cwd, }) {
    const remotes = await (0, git_1.getRepoInfoFromGitRemotes)({ cwd });
    const firstRemote = (0, maybe_1.maybe)(remotes[0]);
    if (!firstRemote) {
        return {};
    }
    try {
        const res = await (0, apiRequestV4_1.apiRequestV4)({
            githubApiBaseUrlV4,
            accessToken,
            query,
            variables: {
                repoOwner: firstRemote.repoOwner,
                repoName: firstRemote.repoName,
            },
        });
        return {
            repoName: res.repository.name,
            // get the original owner (not the fork owner)
            repoOwner: res.repository.isFork
                ? res.repository.parent.owner.login
                : res.repository.owner.login,
        };
    }
    catch (e) {
        if (e instanceof apiRequestV4_1.GithubV4Exception) {
            logger_1.logger.error(e.message);
            return {};
        }
        throw e;
    }
}
exports.getRepoOwnerAndNameFromGitRemotes = getRepoOwnerAndNameFromGitRemotes;
const query = (0, graphql_tag_1.default) `
  query RepoOwnerAndName($repoOwner: String!, $repoName: String!) {
    repository(owner: $repoOwner, name: $repoName) {
      isFork
      name
      owner {
        login
      }
      parent {
        owner {
          login
        }
      }
    }
  }
`;
