"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __importDefault(require("crypto"));
const rest_1 = require("@octokit/rest");
const getDevAccessToken_1 = require("../../../test/private/getDevAccessToken");
const createPullRequest_1 = require("../v3/createPullRequest");
const disablePullRequestAutoMerge_1 = require("./disablePullRequestAutoMerge");
const enablePullRequestAutoMerge_1 = require("./enablePullRequestAutoMerge");
const fetchPullRequestAutoMergeMethod_1 = require("./fetchPullRequestAutoMergeMethod");
// The test repo requires auto-merge being enabled in options, as well as all merge types enabled (merge, squash, rebase)
// The test pull requests should be open, and not currently able to be merged (e.g. because it requires an approval),
// otherwise it will be merged when auto-merge is turned on
const TEST_REPO_OWNER = 'backport-org';
const TEST_REPO_NAME = 'repo-with-auto-merge-enabled';
const INITIAL_SHA = '70aa879411e95b6662f8ddcb80a944fc4444579f';
jest.setTimeout(10000);
const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
function resetReference(octokit) {
    return octokit.rest.git.updateRef({
        owner: TEST_REPO_OWNER,
        repo: TEST_REPO_NAME,
        ref: 'heads/main',
        sha: INITIAL_SHA,
        force: true,
    });
}
async function closePr(octokit, pullNumber) {
    await octokit.pulls.update({
        owner: TEST_REPO_OWNER,
        repo: TEST_REPO_NAME,
        pull_number: pullNumber,
        state: 'closed',
    });
}
async function createPr(options, branchName) {
    const prPayload = {
        base: '7.x',
        head: branchName,
        body: 'testing...',
        owner: TEST_REPO_OWNER,
        repo: TEST_REPO_NAME,
        title: 'my pr title',
    };
    const { number } = await (0, createPullRequest_1.createPullRequest)({ options, prPayload });
    return number;
}
async function deleteBranch(octokit, branchName) {
    await octokit.git.deleteRef({
        owner: TEST_REPO_OWNER,
        repo: TEST_REPO_NAME,
        ref: `heads/${branchName}`,
    });
}
async function createBranch(octokit, branchName, sha) {
    await octokit.git.createRef({
        owner: TEST_REPO_OWNER,
        repo: TEST_REPO_NAME,
        ref: `refs/heads/${branchName}`,
        sha,
    });
}
async function addCommit(octokit) {
    const randomString = Math.random().toString(36).slice(2);
    const res = await octokit.rest.repos.createOrUpdateFileContents({
        owner: TEST_REPO_OWNER,
        repo: TEST_REPO_NAME,
        path: `file-to-change-${randomString}`,
        message: 'Automatically changed',
        content: Buffer.from(`My new hash ${randomString}`).toString('base64'),
        branch: 'main',
    });
    const sha = res.data.commit.sha;
    return sha;
}
// Error: cannot have more than 100 pull requests with the same head_sha
// TODO: have unique head sha for every test run
// eslint-disable-next-line jest/no-disabled-tests
describe('enablePullRequestAutoMerge', () => {
    let pullNumber;
    let branchName;
    let octokit;
    let options;
    beforeAll(async () => {
        const accessToken = (0, getDevAccessToken_1.getDevAccessToken)();
        const randomString = crypto_1.default.randomBytes(4).toString('hex');
        branchName = `test-${randomString}`;
        options = {
            accessToken,
            repoOwner: TEST_REPO_OWNER,
            repoName: TEST_REPO_NAME,
        };
        octokit = new rest_1.Octokit({ auth: accessToken });
        await resetReference(octokit);
        const sha = await addCommit(octokit);
        if (sha) {
            await createBranch(octokit, branchName, sha);
        }
        pullNumber = await createPr(options, branchName);
    });
    // cleanup
    afterAll(async () => {
        await closePr(octokit, pullNumber);
        await deleteBranch(octokit, branchName);
        await resetReference(octokit);
    });
    // reset auto-merge state between runs
    afterEach(async () => {
        await (0, disablePullRequestAutoMerge_1.disablePullRequestAutoMerge)(options, pullNumber);
    });
    it('should initially have auto-merge disabled', async () => {
        const autoMergeMethod = await (0, fetchPullRequestAutoMergeMethod_1.fetchPullRequestAutoMergeMethod)(options, pullNumber);
        expect(autoMergeMethod).toBe(undefined);
    });
    it('should enable auto-merge via merge', async () => {
        await (0, enablePullRequestAutoMerge_1.enablePullRequestAutoMerge)({ ...options, autoMergeMethod: 'merge' }, pullNumber);
        // ensure Github API reflects the change before querying
        await sleep(100);
        const autoMergeMethod = await (0, fetchPullRequestAutoMergeMethod_1.fetchPullRequestAutoMergeMethod)(options, pullNumber);
        expect(autoMergeMethod).toBe('MERGE');
    });
    it('should not enable auto-merge via rebase because it is disallowed', async () => {
        await (0, enablePullRequestAutoMerge_1.enablePullRequestAutoMerge)({ ...options, autoMergeMethod: 'rebase' }, pullNumber);
        // ensure Github API reflects the change before querying
        await sleep(100);
        const autoMergeMethod = await (0, fetchPullRequestAutoMergeMethod_1.fetchPullRequestAutoMergeMethod)(options, pullNumber);
        expect(autoMergeMethod).toBe(undefined);
    });
    it('should enable auto-merge via squash', async () => {
        await (0, enablePullRequestAutoMerge_1.enablePullRequestAutoMerge)({ ...options, autoMergeMethod: 'squash' }, pullNumber);
        // ensure Github API reflects the change before querying
        await sleep(100);
        const autoMergeMethod = await (0, fetchPullRequestAutoMergeMethod_1.fetchPullRequestAutoMergeMethod)(options, pullNumber);
        expect(autoMergeMethod).toBe('SQUASH');
    });
});
