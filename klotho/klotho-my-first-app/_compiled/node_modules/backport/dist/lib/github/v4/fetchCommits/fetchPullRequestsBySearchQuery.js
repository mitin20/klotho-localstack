"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchPullRequestsBySearchQuery = void 0;
const graphql_tag_1 = __importDefault(require("graphql-tag"));
const lodash_1 = require("lodash");
const filterUnmergedCommits_1 = require("../../../../utils/filterUnmergedCommits");
const BackportError_1 = require("../../../BackportError");
const remoteConfig_1 = require("../../../remoteConfig");
const parseSourceCommit_1 = require("../../../sourceCommit/parseSourceCommit");
const apiRequestV4_1 = require("../apiRequestV4");
async function fetchPullRequestsBySearchQuery(options) {
    const { accessToken, author, dateSince, dateUntil, githubApiBaseUrlV4 = 'https://api.github.com/graphql', maxNumber = 10, prFilter, repoName, repoOwner, sourceBranch, } = options;
    const query = (0, graphql_tag_1.default) `
    query PullRequestBySearchQuery($query: String!, $maxNumber: Int!) {
      search(query: $query, type: ISSUE, first: $maxNumber) {
        nodes {
          ... on PullRequest {
            mergeCommit {
              ...SourceCommitWithTargetPullRequestFragment
            }
          }
        }
      }
    }

    ${parseSourceCommit_1.SourceCommitWithTargetPullRequestFragment}
  `;
    function dateFilter() {
        if (dateUntil && dateSince) {
            return [`merged:${dateSince}..${dateUntil}`];
        }
        if (dateUntil) {
            return [`merged:<${dateUntil}`];
        }
        if (dateSince) {
            return [`merged:>${dateSince}`];
        }
        return [];
    }
    const searchQuery = [
        'type:pr',
        'is:merged',
        'sort:created-desc',
        `repo:${repoOwner}/${repoName}`,
        ...(options.author ? [`author:${options.author}`] : []),
        ...(prFilter.includes('base:') ? [] : [`base:${sourceBranch}`]),
        ...dateFilter(),
        prFilter,
    ].join(' ');
    const variables = {
        query: searchQuery,
        maxNumber,
    };
    let res;
    try {
        res = await (0, apiRequestV4_1.apiRequestV4)({
            githubApiBaseUrlV4,
            accessToken,
            query,
            variables,
        });
    }
    catch (e) {
        res = (0, remoteConfig_1.swallowMissingConfigFileException)(e);
    }
    const commits = res.search.nodes.map((pullRequestNode) => {
        const sourceCommit = pullRequestNode.mergeCommit;
        return (0, parseSourceCommit_1.parseSourceCommit)({ options, sourceCommit });
    });
    // terminate if not commits were found
    if ((0, lodash_1.isEmpty)(commits)) {
        const errorText = author
            ? `No commits found for query:\n    ${searchQuery}\n\nUse \`--all\` to see commits by all users or \`--author=<username>\` for commits from a specific user`
            : `No commits found for query:\n    ${searchQuery}`;
        throw new BackportError_1.BackportError(errorText);
    }
    if (options.onlyMissing) {
        return commits.filter(filterUnmergedCommits_1.filterUnmergedCommits);
    }
    return commits;
}
exports.fetchPullRequestsBySearchQuery = fetchPullRequestsBySearchQuery;
