"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupRepo = void 0;
const del = require("del");
const BackportError_1 = require("./BackportError");
const env_1 = require("./env");
const git_1 = require("./git");
const ora_1 = require("./ora");
async function setupRepo(options) {
    const repoPath = (0, env_1.getRepoPath)(options);
    const isAlreadyCloned = await getIsRepoCloned(options);
    // clone repo if folder does not already exists
    if (!isAlreadyCloned) {
        if (options.cwd.includes(repoPath)) {
            throw new BackportError_1.BackportError(`Refusing to clone repo into "${repoPath}" when current working directory is "${options.cwd}". Please change backport directory via \`--dir\` option or run backport from another location`);
        }
        const spinner = (0, ora_1.ora)(options.interactive).start();
        try {
            const localRepoPath = await (0, git_1.getLocalSourceRepoPath)(options);
            const remoteRepoPath = (0, git_1.getRemoteUrl)(options, options.repoOwner);
            const sourcePath = localRepoPath ? localRepoPath : remoteRepoPath;
            // show the full path for local repos, but only the host name for remote repos (to avoid showing the access token)
            const sourcePathHumanReadable = !localRepoPath
                ? options.gitHostname
                : sourcePath;
            const spinnerCloneText = `Cloning repository from ${sourcePathHumanReadable} (one-time operation)`;
            spinner.text = `0% ${spinnerCloneText}`;
            await del(repoPath, { force: true });
            await (0, git_1.cloneRepo)({ sourcePath, targetPath: repoPath }, (progress) => {
                spinner.text = `${progress}% ${spinnerCloneText}`;
            });
            spinner.succeed(`100% ${spinnerCloneText}`);
        }
        catch (e) {
            spinner.fail();
            await del(repoPath, { force: true });
            throw e;
        }
    }
    // delete default "origin" remote to avoid confusion
    await (0, git_1.deleteRemote)(options, 'origin');
    // ensure remote are setup with latest accessToken
    await (0, git_1.deleteRemote)(options, options.repoForkOwner);
    await (0, git_1.addRemote)(options, options.repoForkOwner);
    // add remote for non-fork repo (if the above is a fork)
    if (options.repoForkOwner !== options.repoOwner) {
        await (0, git_1.deleteRemote)(options, options.repoOwner);
        await (0, git_1.addRemote)(options, options.repoOwner);
    }
}
exports.setupRepo = setupRepo;
async function getIsRepoCloned(options) {
    const repoPath = (0, env_1.getRepoPath)(options);
    const projectRoot = await (0, git_1.getGitProjectRootPath)(repoPath);
    return repoPath === projectRoot;
}
