"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCommitsWithoutBackports = void 0;
const chalk_1 = __importDefault(require("chalk"));
const git_1 = require("./git");
const commitFormatters_1 = require("./github/commitFormatters");
const fetchCommitsByAuthor_1 = require("./github/v4/fetchCommits/fetchCommitsByAuthor");
// when the user is facing a git conflict we should help them understand
// why the conflict occurs. In many cases it's because one or more commits haven't been backported yet
async function getCommitsWithoutBackports({ options, 
// commit that is being backported
commit, 
// branch the commit is being backported to
targetBranch, 
// the files with conflicts on the target branch
conflictingFiles, }) {
    // commits on the source branch that also touched the conflicting files
    const commitsInConflictingPaths = await (0, fetchCommitsByAuthor_1.fetchCommitsByAuthor)({
        ...options,
        author: null,
        dateSince: null,
        dateUntil: commit.sourceCommit.committedDate,
        commitPaths: conflictingFiles,
    });
    const promises = await Promise.all(commitsInConflictingPaths
        .filter((c) => {
        // exclude the commit we are currently trying to backport
        if (c.sourceCommit.sha === commit.sourceCommit.sha) {
            return false;
        }
        // exclude commits that are newer than the commit we are trying to backport
        if (c.sourceCommit.committedDate > commit.sourceCommit.committedDate) {
            return false;
        }
        // only consider commits that have an associated pull request
        if (!c.sourcePullRequest?.url) {
            return false;
        }
        // only include commit if it has an unmerged PR for the given target branch
        const hasUnmergedPr = c.pullRequestStates.some((pr) => pr.branch === targetBranch && pr.state !== 'MERGED');
        return hasUnmergedPr;
    })
        .slice(0, 10) // limit to max 10 commits
        .map(async (c) => {
        const results = await Promise.all(c.pullRequestStates.map(async (targetPr) => {
            if (!targetPr.mergeCommit) {
                return false;
            }
            return (0, git_1.getIsCommitInBranch)(options, targetPr.mergeCommit.sha);
        }));
        const isCommitInBranch = results.some((inBranch) => inBranch === true);
        return { c, isCommitInBranch };
    }));
    return promises
        .filter(({ isCommitInBranch }) => !isCommitInBranch)
        .map(({ c }) => {
        // get pull request for the target branch (if it exists)
        const pendingBackportPr = c.pullRequestStates.find((pr) => pr.branch === targetBranch && pr.state === 'OPEN');
        const formatted = pendingBackportPr
            ? ` - ${(0, commitFormatters_1.getFirstLine)(c.sourceCommit.message)} ${chalk_1.default.gray('(backport pending)')}\n   ${pendingBackportPr.url}`
            : ` - ${(0, commitFormatters_1.getFirstLine)(c.sourceCommit.message)} ${chalk_1.default.red('(backport missing)')}\n   ${c.sourcePullRequest?.url}`;
        return { formatted, commit: c };
    });
}
exports.getCommitsWithoutBackports = getCommitsWithoutBackports;
