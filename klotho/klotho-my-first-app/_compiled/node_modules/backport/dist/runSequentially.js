"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runSequentially = void 0;
const BackportError_1 = require("./lib/BackportError");
const cherrypickAndCreateTargetPullRequest_1 = require("./lib/cherrypickAndCreateTargetPullRequest");
const logger_1 = require("./lib/logger");
const sequentially_1 = require("./lib/sequentially");
async function runSequentially({ options, commits, targetBranches, }) {
    logger_1.logger.verbose('Backport options', options);
    const results = [];
    await (0, sequentially_1.sequentially)(targetBranches, async (targetBranch) => {
        logger_1.logger.info(`Backporting ${JSON.stringify(commits)} to ${targetBranch}`);
        try {
            const { number, url, didUpdate } = await (0, cherrypickAndCreateTargetPullRequest_1.cherrypickAndCreateTargetPullRequest)({
                options,
                commits,
                targetBranch,
            });
            results.push({
                targetBranch,
                status: 'success',
                didUpdate,
                pullRequestUrl: url,
                pullRequestNumber: number,
            });
        }
        catch (e) {
            const isHandledError = e instanceof BackportError_1.BackportError;
            if (isHandledError) {
                results.push({
                    targetBranch,
                    status: 'handled-error',
                    error: e,
                });
            }
            else if (e instanceof Error) {
                results.push({
                    targetBranch,
                    status: 'unhandled-error',
                    error: e,
                });
            }
            else {
                throw e;
            }
            (0, logger_1.consoleLog)(isHandledError
                ? e.message
                : 'An unhandled error occurred while backporting commit. Please see the logs for details');
            logger_1.logger.error('runSequentially failed', e);
        }
    });
    // return the results for consumers to programatically read
    return results;
}
exports.runSequentially = runSequentially;
