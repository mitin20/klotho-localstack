"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SafeReviver = void 0;
/**
 * JSON/YAML reviver that:
 *
 * - Throws when an illegal key is detected.
 * - Replaces illegal values with a special marker.
 */
class SafeReviver {
    constructor(props) {
        var _a, _b;
        this.allowlistedKeys = (_a = props === null || props === void 0 ? void 0 : props.allowlistedKeys) !== null && _a !== void 0 ? _a : [];
        this.sanitizers = (_b = props === null || props === void 0 ? void 0 : props.sanitizers) !== null && _b !== void 0 ? _b : [];
    }
    sanitizeValue(path, value) {
        for (const sanitizer of this.sanitizers) {
            const { applied, sanitized } = sanitizer(path, value);
            if (applied) {
                return sanitized;
            }
        }
        return value;
    }
    /**
     * Sanitizes a JSON object in-place.
     */
    sanitize(obj) {
        if (obj == null)
            return;
        this._sanitizeObj([], obj);
    }
    _sanitizeObj(path, partialObj) {
        for (const [key, value] of Object.entries(partialObj)) {
            if (typeof (key) !== 'string') {
                throw new Error(`Expected key (${key}) to be of type 'string', but got '${typeof (key)}'`);
            }
            if (!this.allowlistedKeys.includes(key) && !SafeReviver.LEGAL_CHARS.test(key)) {
                // keys cannot be stripped so we have to throw - thats ok, we don't want to parse such docs at all
                throw new Error(`Key '${key}' contains non standard characters (Must match regex '${SafeReviver.LEGAL_CHARS}')`);
            }
            const childPath = path.concat([key]);
            if (typeof (value) === 'string') {
                partialObj[key] = this.sanitizeValue(childPath, value);
            }
            else if (typeof (value) === 'object' && value !== null) {
                this._sanitizeObj(childPath, value); // recursive call
            }
        }
    }
}
exports.SafeReviver = SafeReviver;
// . | used in resource fqn which servers as a key (e.g io.k8s.apimachinery.pkg.apis.meta.v1.APIGroup)
// / | used in $ref to point to a definition (e.g #/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery)
// - | used in annotation keys (e.g x-kubernetes-group-version-kind)
// # | used in $ref to point to a definition (e.g #/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery)
// , | used in values that represent a list (e.g merge,retainKeys)
SafeReviver.LEGAL_CHARS = /^(\w|\.|\/|-|#|,)*$/;
SafeReviver.LEGAL_CHARS_IN_ENUM = /^( |\w|\.|\/|-|#|,)*$/;
// the string we use as the stripped value
SafeReviver.STRIPPED_VALUE = '__stripped_by_cdk8s__';
// remove characters from descriptions that might terminate the comment
SafeReviver.DESCRIPTION_SANITIZER = (path, value) => {
    if (path.length > 0 && path[path.length - 1] === 'description') {
        return { applied: true, sanitized: value.replace(/\*\//g, '_/') };
    }
    else {
        return { applied: false };
    }
};
// strip most illegal values
// the reason we don't throw is because sometimes these type of values exist in
// the original text for good reason, like for example a `jsonPath` key in a CRD manifest, and we don't
// want to fail the entire thing.
SafeReviver.LEGAL_CHAR_SANITIZER = (path, value) => {
    // case 1: we are in an array of enums
    if (path.length > 2 && path[path.length - 2] === 'enum' && /^\d+$/.test(path[path.length - 1])) {
        if (!SafeReviver.LEGAL_CHARS_IN_ENUM.test(value)) {
            return { applied: true, sanitized: SafeReviver.STRIPPED_VALUE };
        }
        else {
            return { applied: false };
        }
        // case 2: default
    }
    else {
        if (!SafeReviver.LEGAL_CHARS.test(value)) {
            return { applied: true, sanitized: SafeReviver.STRIPPED_VALUE };
        }
        else {
            return { applied: false };
        }
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmV2aXZlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9yZXZpdmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQWNBOzs7OztHQUtHO0FBQ0gsTUFBYSxXQUFXO0lBbUR0QixZQUFZLEtBQXdCOztRQUNsQyxJQUFJLENBQUMsZUFBZSxHQUFHLE1BQUEsS0FBSyxhQUFMLEtBQUssdUJBQUwsS0FBSyxDQUFFLGVBQWUsbUNBQUksRUFBRSxDQUFDO1FBQ3BELElBQUksQ0FBQyxVQUFVLEdBQUcsTUFBQSxLQUFLLGFBQUwsS0FBSyx1QkFBTCxLQUFLLENBQUUsVUFBVSxtQ0FBSSxFQUFFLENBQUM7SUFDNUMsQ0FBQztJQUVNLGFBQWEsQ0FBQyxJQUFjLEVBQUUsS0FBYTtRQUNoRCxLQUFLLE1BQU0sU0FBUyxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDdkMsTUFBTSxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsR0FBRyxTQUFTLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ3RELElBQUksT0FBTyxFQUFFO2dCQUNYLE9BQU8sU0FBUyxDQUFDO2FBQ2xCO1NBQ0Y7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7T0FFRztJQUNJLFFBQVEsQ0FBQyxHQUFRO1FBQ3RCLElBQUksR0FBRyxJQUFJLElBQUk7WUFBRSxPQUFPO1FBQ3hCLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFTyxZQUFZLENBQUMsSUFBYyxFQUFFLFVBQWU7UUFDbEQsS0FBSyxNQUFNLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDckQsSUFBSSxPQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssUUFBUSxFQUFFO2dCQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLGlCQUFpQixHQUFHLHNDQUFzQyxP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ZXNDb250ZW50IjpbIi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgdmFsdWUgYW5kIHRoZSBwYXRoIHRvIGl0IHdpdGhpbiB0aGUgcGFyZW50IG9iamVjdCxcbiAqIGFuZCBlaXRoZXIgdHJhbnNmb3JtcyBpdCBvciBsZWF2ZXMgaXQgYWxvbmUuXG4gKi9cbmV4cG9ydCB0eXBlIFNhbml0aXplciA9IChwYXRoOiBzdHJpbmdbXSwgdmFsdWU6IHN0cmluZykgPT4geyBhcHBsaWVkOiBib29sZWFuOyBzYW5pdGl6ZWQ/OiBzdHJpbmcgfTtcblxuLyoqXG4gKiBQcm9wZXJ0aWVzIGZvciAnU2FmZVJldml2ZXInLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNhZmVSZXZpdmVyUHJvcHMge1xuICByZWFkb25seSBhbGxvd2xpc3RlZEtleXM/OiBzdHJpbmdbXTtcbiAgcmVhZG9ubHkgc2FuaXRpemVycz86IEFycmF5PFNhbml0aXplcj47XG59XG5cbi8qKlxuICogSlNPTi9ZQU1MIHJldml2ZXIgdGhhdDpcbiAqXG4gKiAtIFRocm93cyB3aGVuIGFuIGlsbGVnYWwga2V5IGlzIGRldGVjdGVkLlxuICogLSBSZXBsYWNlcyBpbGxlZ2FsIHZhbHVlcyB3aXRoIGEgc3BlY2lhbCBtYXJrZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBTYWZlUmV2aXZlciB7XG5cbiAgLy8gLiB8IHVzZWQgaW4gcmVzb3VyY2UgZnFuIHdoaWNoIHNlcnZlcnMgYXMgYSBrZXkgKGUuZyBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuQVBJR3JvdXApXG4gIC8vIC8gfCB1c2VkIGluICRyZWYgdG8gcG9pbnQgdG8gYSBkZWZpbml0aW9uIChlLmcgIy9kZWZpbml0aW9ucy9pby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuR3JvdXBWZXJzaW9uRm9yRGlzY292ZXJ5KVxuICAvLyAtIHwgdXNlZCBpbiBhbm5vdGF0aW9uIGtleXMgKGUuZyB4LWt1YmVybmV0ZXMtZ3JvdXAtdmVyc2lvbi1raW5kKVxuICAvLyAjIHwgdXNlZCBpbiAkcmVmIHRvIHBvaW50IHRvIGEgZGVmaW5pdGlvbiAoZS5nICMvZGVmaW5pdGlvbnMvaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLkdyb3VwVmVyc2lvbkZvckRpc2NvdmVyeSlcbiAgLy8gLCB8IHVzZWQgaW4gdmFsdWVzIHRoYXQgcmVwcmVzZW50IGEgbGlzdCAoZS5nIG1lcmdlLHJldGFpbktleXMpXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTEVHQUxfQ0hBUlMgPSAvXihcXHd8XFwufFxcL3wtfCN8LCkqJC87XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTEVHQUxfQ0hBUlNfSU5fRU5VTSA9IC9eKCB8XFx3fFxcLnxcXC98LXwjfCwpKiQvO1xuXG4gIC8vIHRoZSBzdHJpbmcgd2UgdXNlIGFzIHRoZSBzdHJpcHBlZCB2YWx1ZVxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFNUUklQUEVEX1ZBTFVFID0gJ19fc3RyaXBwZWRfYnlfY2RrOHNfXyc7XG5cbiAgLy8gcmVtb3ZlIGNoYXJhY3RlcnMgZnJvbSBkZXNjcmlwdGlvbnMgdGhhdCBtaWdodCB0ZXJtaW5hdGUgdGhlIGNvbW1lbnRcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBERVNDUklQVElPTl9TQU5JVElaRVI6IFNhbml0aXplciA9IChwYXRoOiBzdHJpbmdbXSwgdmFsdWU6IHN0cmluZykgPT4ge1xuICAgIGlmIChwYXRoLmxlbmd0aCA+IDAgJiYgcGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnZGVzY3JpcHRpb24nKSB7XG4gICAgICByZXR1cm4geyBhcHBsaWVkOiB0cnVlLCBzYW5pdGl6ZWQ6IHZhbHVlLnJlcGxhY2UoL1xcKlxcLy9nLCAnXy8nKSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBhcHBsaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgfTtcblxuICAvLyBzdHJpcCBtb3N0IGlsbGVnYWwgdmFsdWVzXG4gIC8vIHRoZSByZWFzb24gd2UgZG9uJ3QgdGhyb3cgaXMgYmVjYXVzZSBzb21ldGltZXMgdGhlc2UgdHlwZSBvZiB2YWx1ZXMgZXhpc3QgaW5cbiAgLy8gdGhlIG9yaWdpbmFsIHRleHQgZm9yIGdvb2QgcmVhc29uLCBsaWtlIGZvciBleGFtcGxlIGEgYGpzb25QYXRoYCBrZXkgaW4gYSBDUkQgbWFuaWZlc3QsIGFuZCB3ZSBkb24ndFxuICAvLyB3YW50IHRvIGZhaWwgdGhlIGVudGlyZSB0aGluZy5cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBMRUdBTF9DSEFSX1NBTklUSVpFUjogU2FuaXRpemVyID0gKHBhdGg6IHN0cmluZ1tdLCB2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgLy8gY2FzZSAxOiB3ZSBhcmUgaW4gYW4gYXJyYXkgb2YgZW51bXNcbiAgICBpZiAocGF0aC5sZW5ndGggPiAyICYmIHBhdGhbcGF0aC5sZW5ndGggLSAyXSA9PT0gJ2VudW0nICYmIC9eXFxkKyQvLnRlc3QocGF0aFtwYXRoLmxlbmd0aCAtIDFdKSkge1xuXG4gICAgICBpZiAoIVNhZmVSZXZpdmVyLkxFR0FMX0NIQVJTX0lOX0VOVU0udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgYXBwbGllZDogdHJ1ZSwgc2FuaXRpemVkOiBTYWZlUmV2aXZlci5TVFJJUFBFRF9WQUxVRSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgYXBwbGllZDogZmFsc2UgfTtcbiAgICAgIH1cblxuICAgIC8vIGNhc2UgMjogZGVmYXVsdFxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGlmICghU2FmZVJldml2ZXIuTEVHQUxfQ0hBUlMudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgYXBwbGllZDogdHJ1ZSwgc2FuaXRpemVkOiBTYWZlUmV2aXZlci5TVFJJUFBFRF9WQUxVRSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgYXBwbGllZDogZmFsc2UgfTtcbiAgICAgIH1cblxuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIHJlYWRvbmx5IGFsbG93bGlzdGVkS2V5czogc3RyaW5nW107XG4gIHByaXZhdGUgcmVhZG9ubHkgc2FuaXRpemVyczogQXJyYXk8U2FuaXRpemVyPjtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcz86IFNhZmVSZXZpdmVyUHJvcHMpIHtcbiAgICB0aGlzLmFsbG93bGlzdGVkS2V5cyA9IHByb3BzPy5hbGxvd2xpc3RlZEtleXMgPz8gW107XG4gICAgdGhpcy5zYW5pdGl6ZXJzID0gcHJvcHM/LnNhbml0aXplcnMgPz8gW107XG4gIH1cblxuICBwdWJsaWMgc2FuaXRpemVWYWx1ZShwYXRoOiBzdHJpbmdbXSwgdmFsdWU6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgZm9yIChjb25zdCBzYW5pdGl6ZXIgb2YgdGhpcy5zYW5pdGl6ZXJzKSB7XG4gICAgICBjb25zdCB7IGFwcGxpZWQsIHNhbml0aXplZCB9ID0gc2FuaXRpemVyKHBhdGgsIHZhbHVlKTtcbiAgICAgIGlmIChhcHBsaWVkKSB7XG4gICAgICAgIHJldHVybiBzYW5pdGl6ZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhbml0aXplcyBhIEpTT04gb2JqZWN0IGluLXBsYWNlLlxuICAgKi9cbiAgcHVibGljIHNhbml0aXplKG9iajogYW55KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm47XG4gICAgdGhpcy5fc2FuaXRpemVPYmooW10sIG9iaik7XG4gIH1cblxuICBwcml2YXRlIF9zYW5pdGl6ZU9iaihwYXRoOiBzdHJpbmdbXSwgcGFydGlhbE9iajogYW55KSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFydGlhbE9iaikpIHtcbiAgICAgIGlmICh0eXBlb2Yoa2V5KSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBrZXkgKCR7a2V5fSkgdG8gYmUgb2YgdHlwZSAnc3RyaW5nJywgYnV0IGdvdCAnJHt0eXBlb2Yoa2V5KX0nYCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5hbGxvd2xpc3RlZEtleXMuaW5jbHVkZXMoa2V5KSAmJiAhU2FmZVJldml2ZXIuTEVHQUxfQ0hBUlMudGVzdChrZXkpKSB7XG4gICAgICAgIC8vIGtleXMgY2Fubm90IGJlIHN0cmlwcGVkIHNvIHdlIGhhdmUgdG8gdGhyb3cgLSB0aGF0cyBvaywgd2UgZG9uJ3Qgd2FudCB0byBwYXJzZSBzdWNoIGRvY3MgYXQgYWxsXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ICcke2tleX0nIGNvbnRhaW5zIG5vbiBzdGFuZGFyZCBjaGFyYWN0ZXJzIChNdXN0IG1hdGNoIHJlZ2V4ICcke1NhZmVSZXZpdmVyLkxFR0FMX0NIQVJTfScpYCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGguY29uY2F0KFtrZXldKTtcblxuICAgICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhcnRpYWxPYmpba2V5XSA9IHRoaXMuc2FuaXRpemVWYWx1ZShjaGlsZFBhdGgsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fc2FuaXRpemVPYmooY2hpbGRQYXRoLCB2YWx1ZSk7IC8vIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXX0=