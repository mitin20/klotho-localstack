{"version":3,"file":"validator.js","sourceRoot":"","sources":["../src/validator.ts"],"names":[],"mappings":"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","sourcesContent":["import * as assert from 'node:assert';\nimport * as spec from '@jsii/spec';\nimport * as deepEqual from 'fast-deep-equal';\nimport * as ts from 'typescript';\n\nimport * as Case from './case';\nimport { Emitter } from './emitter';\nimport { JsiiDiagnostic } from './jsii-diagnostic';\nimport { getRelatedNode } from './node-bindings';\nimport * as bindings from './node-bindings';\nimport { ProjectInfo } from './project-info';\n\nexport class Validator implements Emitter {\n  public static VALIDATIONS: ValidationFunction[] = _defaultValidations();\n\n  public constructor(public readonly projectInfo: ProjectInfo, public readonly assembly: spec.Assembly) {}\n\n  public emit(): ts.EmitResult {\n    const diagnostics = new Array<ts.Diagnostic>();\n\n    for (const validation of Validator.VALIDATIONS) {\n      validation(this, this.assembly, diagnostics.push.bind(diagnostics));\n    }\n\n    return {\n      diagnostics: diagnostics,\n      emitSkipped: diagnostics.some((diag) => diag.category === ts.DiagnosticCategory.Error),\n    };\n  }\n}\n\nexport type DiagnosticEmitter = (diag: JsiiDiagnostic) => void;\nexport type ValidationFunction = (validator: Validator, assembly: spec.Assembly, diagnostic: DiagnosticEmitter) => void;\n\nfunction _defaultValidations(): ValidationFunction[] {\n  return [\n    _enumMembersMustUserUpperSnakeCase,\n    _memberNamesMustUseCamelCase,\n    _staticConstantNamesMustUseUpperSnakeCase,\n    _memberNamesMustNotLookLikeJavaGettersOrSetters,\n    _allTypeReferencesAreValid,\n    _inehritanceDoesNotChangeContracts,\n    _staticMembersAndNestedTypesMustNotSharePascalCaseName,\n  ];\n\n  function _enumMembersMustUserUpperSnakeCase(_: Validator, assembly: spec.Assembly, diagnostic: DiagnosticEmitter) {\n    for (const type of _allTypes(assembly)) {\n      if (!spec.isEnumType(type)) {\n        continue;\n      }\n\n      for (const member of type.members) {\n        if (member.name && !isConstantCase(member.name)) {\n          diagnostic(JsiiDiagnostic.JSII_8001_ALL_CAPS_ENUM_MEMBERS.createDetached(member.name, type.fqn));\n        }\n      }\n    }\n  }\n\n  function _memberNamesMustUseCamelCase(_: Validator, assembly: spec.Assembly, diagnostic: DiagnosticEmitter) {\n    for (const { member, type } of _allMembers(assembly)) {\n      if (member.static && (member as spec.Property).const) {\n        continue;\n      }\n      if (member.name && member.name !== Case.camel(member.name)) {\n        diagnostic(JsiiDiagnostic.JSII_8002_CAMEL_CASED_MEMBERS.createDetached(member.name, type.fqn));\n      }\n    }\n  }\n\n  function _staticConstantNamesMustUseUpperSnakeCase(\n    _: Validator,\n    assembly: spec.Assembly,\n    diagnostic: DiagnosticEmitter,\n  ) {\n    for (const { member, type } of _allMembers(assembly)) {\n      if (!member.static || !(member as spec.Property).const) {\n        continue;\n      }\n      if (\n        member.name &&\n        !isConstantCase(member.name) &&\n        member.name !== Case.pascal(member.name) &&\n        member.name !== Case.camel(member.name)\n      ) {\n        diagnostic(JsiiDiagnostic.JSII_8003_STATIC_CONST_CASING.createDetached(member.name, type.name));\n      }\n    }\n  }\n\n  function _memberNamesMustNotLookLikeJavaGettersOrSetters(\n    _: Validator,\n    assembly: spec.Assembly,\n    diagnostic: DiagnosticEmitter,\n  ) {\n    for (const { member, type } of _allMembers(assembly)) {\n      if (!member.name) {\n        continue;\n      }\n      const snakeName = Case.snake(member.name);\n      if (snakeName.startsWith('get_') && _isEmpty((member as spec.Method).parameters)) {\n        diagnostic(JsiiDiagnostic.JSII_5000_JAVA_GETTERS.createDetached(member.name, type.name));\n      } else if (snakeName.startsWith('set_') && ((member as spec.Method).parameters ?? []).length === 1) {\n        diagnostic(JsiiDiagnostic.JSII_5001_JAVA_SETTERS.createDetached(member.name, type.name));\n      }\n    }\n  }\n\n  function _allTypeReferencesAreValid(validator: Validator, assembly: spec.Assembly, diagnostic: DiagnosticEmitter) {\n    for (const typeRef of _allTypeReferences(assembly)) {\n      const [assm] = typeRef.fqn.split('.');\n      if (assembly.name === assm) {\n        if (!(typeRef.fqn in (assembly.types ?? {}))) {\n          diagnostic(\n            JsiiDiagnostic.JSII_3000_EXPORTED_API_USES_HIDDEN_TYPE.create(\n              typeRef.node!, // Pretend there is always a value\n              typeRef.fqn,\n            ),\n          );\n        }\n        continue;\n      }\n      const foreignAssm = validator.projectInfo.dependencyClosure.find((dep) => dep.name === assm);\n      if (!foreignAssm) {\n        diagnostic(JsiiDiagnostic.JSII_9000_UNKNOWN_MODULE.createDetached(assm));\n        continue;\n      }\n      if (!(typeRef.fqn in (foreignAssm.types ?? {}))) {\n        diagnostic(JsiiDiagnostic.JSII_9001_TYPE_NOT_FOUND.createDetached(typeRef));\n      }\n    }\n  }\n\n  function _inehritanceDoesNotChangeContracts(\n    validator: Validator,\n    assembly: spec.Assembly,\n    diagnostic: DiagnosticEmitter,\n  ) {\n    for (const type of _allTypes(assembly)) {\n      if (spec.isClassType(type)) {\n        for (const method of type.methods ?? []) {\n          _validateMethodOverride(method, type);\n        }\n        for (const property of type.properties ?? []) {\n          _validatePropertyOverride(property, type);\n        }\n      }\n      if (spec.isClassOrInterfaceType(type) && (type.interfaces?.length ?? 0) > 0) {\n        for (const method of _allImplementations(type, (t) => t.methods)) {\n          _validateMethodImplementation(method, type);\n        }\n        for (const property of _allImplementations(type, (t) => t.properties)) {\n          _validatePropertyImplementation(property, type);\n        }\n      }\n    }\n\n    /**\n     * Lists all \"implementations\" from the given type, using the provided\n     * implementation getter. Note that abstract members may be part of the\n     * result (in particular, if `type` is an interface type, or if it's an\n     * abstract class with unimplemented members) -- I just couldn't come up\n     * with a name that actually describes this.\n     *\n     * @param type   the type which implemented members are needed.\n     * @param getter the getter to obtain methods or properties from the type.\n     *\n     * @returns a list of members (possibly empty, always defined)\n     */\n    function _allImplementations<T extends spec.Property | spec.Method>(\n      type: spec.ClassType | spec.InterfaceType,\n      getter: (type: spec.ClassType | spec.InterfaceType) => T[] | undefined,\n    ): T[] {\n      const result = new Array<T>();\n      const known = new Set<string>();\n\n      for (const member of getter(type) ?? []) {\n        result.push(member);\n        known.add(member.name);\n      }\n\n      if (spec.isClassType(type) && type.base) {\n        // We have a parent class, collect their concrete members, too (recursively)...\n        const base = _dereference(type.base, assembly, validator);\n        assert(base != null && spec.isClassType(base));\n        for (const member of _allImplementations(base, getter)) {\n          if (known.has(member.name)) {\n            continue;\n          }\n          // The member is copied, so that its `overrides` property won't be\n          // altered, since this member is \"borrowed\" from a parent type. We\n          // only check it, but should not record `overrides` relationships to\n          // it as those could be invalid per the parent type (i.e: the parent\n          // member may not be able to implement an interface, if that type does\n          // not actually declare implementing that).\n          const memberCopy = { ...member };\n          // Forward the related node if there's one, so diagnostics are bound.\n          const node = bindings.getRelatedNode(member);\n          if (node != null) {\n            bindings.setRelatedNode(memberCopy, node);\n          }\n\n          result.push(memberCopy);\n          known.add(member.name);\n        }\n      }\n\n      return result;\n    }\n\n    function _validateMethodOverride(method: spec.Method, type: spec.ClassType): boolean {\n      if (!type.base) {\n        return false;\n      }\n      const baseType = _dereference(type.base, assembly, validator) as spec.ClassType;\n      if (!baseType) {\n        return false;\n      }\n      const overridden = (baseType.methods ?? []).find((m) => m.name === method.name);\n      if (!overridden) {\n        return _validateMethodOverride(method, baseType);\n      }\n      _assertSignaturesMatch(overridden, method, `${type.fqn}#${method.name}`, `overriding ${baseType.fqn}`);\n      method.overrides = baseType.fqn;\n      return true;\n    }\n\n    function _validatePropertyOverride(property: spec.Property, type: spec.ClassType): boolean {\n      if (!type.base) {\n        return false;\n      }\n      const baseType = _dereference(type.base, assembly, validator) as spec.ClassType;\n      if (!baseType) {\n        return false;\n      }\n      const overridden = (baseType.properties ?? []).find((p) => p.name === property.name);\n      if (!overridden) {\n        return _validatePropertyOverride(property, baseType);\n      }\n      _assertPropertiesMatch(overridden, property, `${type.fqn}#${property.name}`, `overriding ${baseType.fqn}`);\n      property.overrides = baseType.fqn;\n      return true;\n    }\n\n    function _validateMethodImplementation(method: spec.Method, type: spec.ClassType | spec.InterfaceType): boolean {\n      if (!type.interfaces) {\n        // Abstract classes may not directly implement all members, need to check their supertypes...\n        if (spec.isClassType(type) && type.base && type.abstract) {\n          return _validateMethodImplementation(method, _dereference(type.base, assembly, validator) as spec.ClassType);\n        }\n        return false;\n      }\n      for (const iface of type.interfaces) {\n        const ifaceType = _dereference(iface, assembly, validator) as spec.InterfaceType;\n        const implemented = (ifaceType.methods ?? []).find((m) => m.name === method.name);\n        if (implemented) {\n          _assertSignaturesMatch(implemented, method, `${type.fqn}#${method.name}`, `implementing ${ifaceType.fqn}`);\n          // We won't replace a previous overrides declaration from a method override, as those have\n          // higher precedence than an initial implementation.\n          method.overrides = method.overrides ?? iface;\n          return true;\n        }\n        if (_validateMethodImplementation(method, ifaceType)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    function _validatePropertyImplementation(\n      property: spec.Property,\n      type: spec.ClassType | spec.InterfaceType,\n    ): boolean {\n      if (!type.interfaces) {\n        // Abstract classes may not directly implement all members, need to check their supertypes...\n        if (spec.isClassType(type) && type.base && type.abstract) {\n          return _validatePropertyImplementation(\n            property,\n            _dereference(type.base, assembly, validator) as spec.ClassType,\n          );\n        }\n        return false;\n      }\n      for (const iface of type.interfaces) {\n        const ifaceType = _dereference(iface, assembly, validator) as spec.InterfaceType;\n        const implemented = (ifaceType.properties ?? []).find((p) => p.name === property.name);\n        if (implemented) {\n          _assertPropertiesMatch(\n            implemented,\n            property,\n            `${type.fqn}#${property.name}`,\n            `implementing ${ifaceType.fqn}`,\n          );\n          // We won't replace a previous overrides declaration from a property override, as those\n          // have higher precedence than an initial implementation.\n          property.overrides = property.overrides ?? ifaceType.fqn;\n          return true;\n        }\n        if (_validatePropertyImplementation(property, ifaceType)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    function _assertSignaturesMatch(expected: spec.Method, actual: spec.Method, label: string, action: string) {\n      if (!!expected.protected !== !!actual.protected) {\n        const expVisibility = expected.protected ? 'protected' : 'public';\n        const actVisibility = actual.protected ? 'protected' : 'public';\n        diagnostic(\n          JsiiDiagnostic.JSII_5002_OVERRIDE_CHANGES_VISIBILITY.createDetached(\n            label,\n            action,\n            actVisibility,\n            expVisibility,\n          ),\n        );\n      }\n      if (!deepEqual(actual.returns, expected.returns)) {\n        const expType = spec.describeTypeReference(expected.returns?.type);\n        const actType = spec.describeTypeReference(actual.returns?.type);\n        diagnostic(\n          JsiiDiagnostic.JSII_5003_OVERRIDE_CHANGES_RETURN_TYPE.createDetached(label, action, actType, expType),\n        );\n      }\n      const expectedParams = expected.parameters ?? [];\n      const actualParams = actual.parameters ?? [];\n      if (expectedParams.length !== actualParams.length) {\n        diagnostic(\n          JsiiDiagnostic.JSII_5005_OVERRIDE_CHANGES_PARAM_COUNT.createDetached(\n            label,\n            action,\n            actualParams.length,\n            expectedParams.length,\n          ),\n        );\n        return;\n      }\n      for (let i = 0; i < expectedParams.length; i++) {\n        const expParam = expectedParams[i];\n        const actParam = actualParams[i];\n        if (!deepEqual(expParam.type, actParam.type)) {\n          diagnostic(\n            JsiiDiagnostic.JSII_5006_OVERRIDE_CHANGES_PARAM_TYPE.createDetached(label, action, actParam, expParam),\n          );\n        }\n        // Not-ing those to force the values to a strictly boolean context (they're optional, undefined means false)\n        if (expParam.variadic !== actParam.variadic) {\n          diagnostic(\n            JsiiDiagnostic.JSII_5007_OVERRIDE_CHANGES_VARIADIC.createDetached(\n              label,\n              action,\n              actParam.variadic,\n              expParam.variadic,\n            ),\n          );\n        }\n        if (expParam.optional !== actParam.optional) {\n          diagnostic(\n            JsiiDiagnostic.JSII_5008_OVERRIDE_CHANGES_PARAM_OPTIONAL.createDetached(label, action, actParam, expParam),\n          );\n        }\n      }\n    }\n\n    function _assertPropertiesMatch(expected: spec.Property, actual: spec.Property, label: string, action: string) {\n      const actualNode = bindings.getPropertyRelatedNode(actual);\n      const expectedNode = bindings.getPropertyRelatedNode(expected);\n      if (!!expected.protected !== !!actual.protected) {\n        const expVisibility = expected.protected ? 'protected' : 'public';\n        const actVisibility = actual.protected ? 'protected' : 'public';\n        diagnostic(\n          JsiiDiagnostic.JSII_5002_OVERRIDE_CHANGES_VISIBILITY.create(\n            actualNode?.modifiers?.find(\n              (mod) => mod.kind === ts.SyntaxKind.PublicKeyword || mod.kind === ts.SyntaxKind.ProtectedKeyword,\n            ) ?? declarationName(actualNode),\n            label,\n            action,\n            actVisibility,\n            expVisibility,\n          ).maybeAddRelatedInformation(\n            expectedNode?.modifiers?.find(\n              (mod) => mod.kind === ts.SyntaxKind.PublicKeyword || mod.kind === ts.SyntaxKind.ProtectedKeyword,\n            ) ?? declarationName(expectedNode),\n            'The implemented delcaration is here.',\n          ),\n        );\n      }\n      if (!deepEqual(expected.type, actual.type)) {\n        diagnostic(\n          JsiiDiagnostic.JSII_5004_OVERRIDE_CHANGES_PROP_TYPE.create(\n            actualNode?.type ?? declarationName(actualNode),\n            label,\n            action,\n            actual.type,\n            expected.type,\n          ).maybeAddRelatedInformation(\n            expectedNode?.type ?? declarationName(expectedNode),\n            'The implemented delcaration is here.',\n          ),\n        );\n      }\n      if (expected.immutable !== actual.immutable) {\n        diagnostic(\n          JsiiDiagnostic.JSII_5010_OVERRIDE_CHANGES_MUTABILITY.create(\n            actualNode?.modifiers?.find((mod) => mod.kind === ts.SyntaxKind.ReadonlyKeyword) ??\n              declarationName(actualNode),\n            label,\n            action,\n            actual.immutable,\n            expected.immutable,\n          ).maybeAddRelatedInformation(\n            expectedNode?.modifiers?.find((mod) => mod.kind === ts.SyntaxKind.ReadonlyKeyword) ??\n              declarationName(expectedNode),\n            'The implemented delcaration is here.',\n          ),\n        );\n      }\n      if (expected.optional !== actual.optional) {\n        diagnostic(\n          JsiiDiagnostic.JSII_5009_OVERRIDE_CHANGES_PROP_OPTIONAL.create(\n            actualNode?.questionToken ?? actualNode?.type ?? declarationName(actualNode),\n            label,\n            action,\n            actual.optional,\n            expected.optional,\n          ).maybeAddRelatedInformation(\n            expectedNode?.questionToken ?? expectedNode?.type ?? declarationName(expectedNode),\n            'The implemented delcaration is here.',\n          ),\n        );\n      }\n    }\n  }\n\n  function _staticMembersAndNestedTypesMustNotSharePascalCaseName(\n    _: Validator,\n    assembly: spec.Assembly,\n    diagnostic: DiagnosticEmitter,\n  ) {\n    for (const nestedType of Object.values(assembly.types ?? {})) {\n      if (nestedType.namespace == null) {\n        continue;\n      }\n      const nestingType = assembly.types![`${assembly.name}.${nestedType.namespace}`];\n      if (nestingType == null) {\n        continue;\n      }\n      const nestedTypeName = Case.pascal(nestedType.name);\n      for (const { name, member } of staticMembers(nestingType)) {\n        if (name === nestedTypeName) {\n          let diag = JsiiDiagnostic.JSII_5020_STATIC_MEMBER_CONFLICTS_WITH_NESTED_TYPE.create(\n            getRelatedNode(member)!,\n            nestingType,\n            member,\n            nestedType,\n          );\n          const nestedTypeNode = getRelatedNode(nestedType);\n          if (nestedTypeNode != null) {\n            diag = diag.addRelatedInformation(nestedTypeNode, 'This is the conflicting nested type declaration');\n          }\n          diagnostic(diag);\n        }\n      }\n    }\n\n    function staticMembers(type: spec.Type) {\n      if (spec.isClassOrInterfaceType(type)) {\n        return [\n          ...(type.methods?.filter((method) => method.static) ?? []),\n          ...(type.properties?.filter((prop) => prop.static) ?? []),\n        ].map((member) => ({ name: Case.pascal(member.name), member }));\n      }\n      return type.members.map((member) => ({ name: member.name, member }));\n    }\n  }\n}\n\nfunction _allTypes(assm: spec.Assembly): spec.Type[] {\n  return Object.values(assm.types ?? {});\n}\n\nfunction _allMethods(assm: spec.Assembly): Array<{ member: spec.Method; type: spec.Type }> {\n  const methods = new Array<{ member: spec.Method; type: spec.Type }>();\n  for (const type of _allTypes(assm)) {\n    if (!spec.isClassOrInterfaceType(type)) {\n      continue;\n    }\n    if (!type.methods) {\n      continue;\n    }\n    for (const method of type.methods) methods.push({ member: method, type });\n  }\n  return methods;\n}\n\nfunction _allProperties(assm: spec.Assembly): Array<{ member: spec.Property; type: spec.Type }> {\n  const properties = new Array<{ member: spec.Property; type: spec.Type }>();\n  for (const type of _allTypes(assm)) {\n    if (!spec.isClassOrInterfaceType(type)) {\n      continue;\n    }\n    if (!type.properties) {\n      continue;\n    }\n    for (const property of type.properties) properties.push({ member: property, type });\n  }\n  return properties;\n}\n\nfunction _allMembers(assm: spec.Assembly): Array<{ member: spec.Property | spec.Method; type: spec.Type }> {\n  return [..._allMethods(assm), ..._allProperties(assm)];\n}\n\ninterface AnnotatedTypeReference extends spec.NamedTypeReference {\n  readonly node: ts.Node | undefined;\n}\n\nfunction _allTypeReferences(assm: spec.Assembly): readonly AnnotatedTypeReference[] {\n  const typeReferences = new Array<AnnotatedTypeReference>();\n  for (const type of _allTypes(assm)) {\n    if (!spec.isClassOrInterfaceType(type)) {\n      continue;\n    }\n    if (spec.isClassType(type)) {\n      const node = bindings.getClassRelatedNode(type);\n      if (type.base) {\n        typeReferences.push({\n          fqn: type.base,\n          node: node?.heritageClauses?.find((hc) => hc.token === ts.SyntaxKind.ExtendsKeyword)?.types[0],\n        });\n      }\n      if (type.initializer?.parameters) {\n        for (const param of type.initializer.parameters) {\n          _collectTypeReferences(param.type, bindings.getParameterRelatedNode(param)?.type);\n        }\n      }\n    }\n    if (type.interfaces) {\n      const node = bindings.getClassOrInterfaceRelatedNode(type);\n      for (const iface of type.interfaces) {\n        typeReferences.push({\n          fqn: iface,\n          node: node?.heritageClauses?.find(\n            (hc) =>\n              hc.token ===\n              (spec.isInterfaceType(type) ? ts.SyntaxKind.ImplementsKeyword : ts.SyntaxKind.ExtendsKeyword),\n          ),\n        });\n      }\n    }\n  }\n  for (const { member: prop } of _allProperties(assm)) {\n    _collectTypeReferences(prop.type, bindings.getPropertyRelatedNode(prop)?.type);\n  }\n  for (const { member: meth } of _allMethods(assm)) {\n    if (meth.returns) {\n      _collectTypeReferences(meth.returns.type, bindings.getMethodRelatedNode(meth)?.type);\n    }\n    for (const param of meth.parameters ?? []) {\n      _collectTypeReferences(param.type, bindings.getParameterRelatedNode(param)?.type);\n    }\n  }\n  return typeReferences;\n\n  function _collectTypeReferences(type: spec.TypeReference, node: ts.Node | undefined): void {\n    if (spec.isNamedTypeReference(type)) {\n      typeReferences.push({ ...type, node });\n    } else if (spec.isCollectionTypeReference(type)) {\n      _collectTypeReferences(type.collection.elementtype, node);\n    } else if (spec.isUnionTypeReference(type)) {\n      for (const t of type.union.types) _collectTypeReferences(t, node);\n    }\n  }\n}\n\nfunction _dereference(\n  typeRef: string | spec.NamedTypeReference,\n  assembly: spec.Assembly,\n  validator: Validator,\n): spec.Type | undefined {\n  if (typeof typeRef !== 'string') {\n    typeRef = typeRef.fqn;\n  }\n  const [assm] = typeRef.split('.');\n  if (assembly.name === assm) {\n    return assembly.types?.[typeRef];\n  }\n  const foreignAssm = validator.projectInfo.dependencyClosure.find((dep) => dep.name === assm);\n  return foreignAssm?.types?.[typeRef];\n}\n\nfunction _isEmpty(array: undefined | any[]): array is undefined {\n  return array == null || array.length === 0;\n}\n\n/**\n * Return whether an identifier only consists of upperchase characters, digits and underscores\n *\n * We have our own check here (isConstantCase) which is more lenient than what\n * `case.constant()` prescribes. We also want to allow combinations of letters\n * and digits without underscores: `C5A`, which `case` would force to `C5_A`.\n * The hint we print will still use `case.constant()` but that is fine.\n */\nfunction isConstantCase(x: string) {\n  return !/[^A-Z0-9_]/.exec(x);\n}\n\n/**\n * Obtains the name of the given declaration, if it has one, or returns the declaration itself.\n * This function is meant to be used as a convenience to obtain the `ts.Node` to bind a\n * `JsiiDianostic` instance on.\n *\n * It may return `undefined` but is typed as `ts.Node` so that it is easier to use with\n * `JsiiDiagnostic` factories.\n *\n * @param decl the declaration which name is needed.\n *\n * @returns the name of the declaration if it has one, or the declaration itself. Might return\n *          `undefined` if the provided declaration is undefined.\n */\nfunction declarationName(decl: ts.Declaration | ts.Expression | undefined): ts.Node {\n  if (decl == null) {\n    // Pretend we returned a node - this is used to create diagnostics, worst case it'll be unbound.\n    return decl as any;\n  }\n  return ts.getNameOfDeclaration(decl) ?? decl;\n}\n"]}