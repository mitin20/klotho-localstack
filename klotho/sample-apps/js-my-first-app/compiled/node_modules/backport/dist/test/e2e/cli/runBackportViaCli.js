"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runBackportViaCli = void 0;
const child_process_1 = require("child_process");
const path_1 = __importDefault(require("path"));
const lodash_1 = require("lodash");
const strip_ansi_1 = __importDefault(require("strip-ansi"));
const sandbox_1 = require("../../sandbox");
const tsNodeBinary = path_1.default.resolve('./node_modules/.bin/ts-node');
const entrypointFile = path_1.default.resolve('./src/entrypoint.cli.ts');
jest.setTimeout(15000);
function runBackportViaCli(backportArgs, runBackportOptions = {}) {
    const chunks = '';
    const randomString = Math.random().toString(36).slice(2);
    const sandboxPath = (0, sandbox_1.getSandboxPath)({
        filename: __filename,
        specname: randomString,
    });
    (0, sandbox_1.resetSandbox)(sandboxPath);
    const cmdArgs = [
        '--transpile-only',
        entrypointFile,
        `--log-file-path=${sandbox_1.SANDBOX_PATH}/backport.log`,
        ...(backportArgs.some((arg) => arg.includes('--dir'))
            ? []
            : [`--dir=${sandboxPath}`]),
        ...backportArgs,
    ];
    const proc = (0, child_process_1.spawn)(tsNodeBinary, cmdArgs, { cwd: runBackportOptions.cwd });
    return getPromise(proc, runBackportOptions, cmdArgs, chunks);
}
exports.runBackportViaCli = runBackportViaCli;
const keyCodeMap = {
    down: '\x1B\x5B\x42',
    up: '\x1B\x5B\x41',
    enter: '\x0D',
};
function getPromise(proc, runBackportOptions, cmdArgs, chunks) {
    if (proc.killed) {
        throw new Error('Process is already killed. Did you forget `keepAlive: true`?');
    }
    const { timeoutSeconds = 3, waitForString, showOra, keepAlive, } = runBackportOptions;
    return new Promise((resolve, reject) => {
        const postponeTimeout = (0, lodash_1.debounce)(() => {
            const formattedChunks = formatChunk(chunks);
            const cmd = [tsNodeBinary, ...cmdArgs].join(' ');
            reject(waitForString
                ? `Expectation '${waitForString}' not found within ${timeoutSeconds} second in:\n\n${formattedChunks}\n\nCommand: ${cmd}`
                : `Process did not complete within ${timeoutSeconds} seconds. Received:\n${formattedChunks}\n\nCommand: ${cmd}`);
        }, timeoutSeconds * 1000, { maxWait: 10000 });
        function formatChunk(data) {
            return (0, strip_ansi_1.default)(data.toString()).trim();
        }
        function keypress(keyCode, runBackportOptions = {}) {
            const p = getPromise(proc, runBackportOptions, cmdArgs, chunks);
            proc.stdin.write(keyCodeMap[keyCode]);
            return p;
        }
        const onChunk = (chunk) => {
            chunks += chunk;
            const formattedChunk = formatChunk(chunk);
            if (waitForString && formattedChunk.includes(waitForString)) {
                postponeTimeout.cancel();
                resolve({ output: formatChunk(chunks), code: null, keypress });
            }
        };
        proc.on('exit', (code) => {
            postponeTimeout.cancel();
            if (waitForString) {
                reject(`runBackportViaCli exited before finding: ${waitForString}. Output: ${formatChunk(chunks)}`);
            }
            else {
                resolve({ output: formatChunk(chunks), code, keypress });
            }
        });
        proc.stdout.on('data', (chunk) => {
            postponeTimeout();
            onChunk(chunk);
        });
        // ora (loading spinner) is redirected to stderr
        proc.stderr.on('data', (chunk) => {
            postponeTimeout();
            if (showOra) {
                onChunk(chunk);
            }
        });
        proc.on('error', (err) => {
            reject(`runBackportViaCli failed with: ${err}`);
        });
    }).finally(() => {
        if (!keepAlive) {
            proc.kill();
        }
        else {
            proc.removeAllListeners('exit');
            proc.stdout.removeAllListeners('data');
            proc.stderr.removeAllListeners('data');
            proc.removeAllListeners('errors');
        }
    });
}
