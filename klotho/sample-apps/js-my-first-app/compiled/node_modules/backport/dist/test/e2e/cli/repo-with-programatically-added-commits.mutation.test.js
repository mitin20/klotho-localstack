"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-console */
const rest_1 = require("@octokit/rest");
const getDevAccessToken_1 = require("../../private/getDevAccessToken");
const sandbox_1 = require("../../sandbox");
const runBackportViaCli_1 = require("./runBackportViaCli");
jest.setTimeout(15000);
const accessToken = (0, getDevAccessToken_1.getDevAccessToken)();
const octokit = new rest_1.Octokit({ auth: accessToken });
describe('Programatically add new commits', () => {
    it('should backport commits added after the first run', async () => {
        const sandboxPath = (0, sandbox_1.getSandboxPath)({ filename: __filename });
        await (0, sandbox_1.resetSandbox)(sandboxPath);
        // first run: backport should clone the repo
        await (0, runBackportViaCli_1.runBackportViaCli)([
            '--repo=backport-org/repo-with-programatically-added-commits',
            '--pr=1',
            '--branch=7.x',
            `--accessToken=${accessToken}`,
            `--dir=${sandboxPath}`,
            '--dry-run',
        ], { showOra: true });
        const formattedDate = new Date().toLocaleString('da-DK');
        const commitMessage = `Automatically added at ${formattedDate}`;
        const sha = await createAndCommitFile({
            commitMessage,
            files: [
                {
                    path: `files/${formattedDate}.md`,
                    sha: await createBlob(`# Hello\nSome content added @ ${formattedDate}`),
                },
            ],
        });
        // second run: backport should find and backport the new commit
        const { output } = await (0, runBackportViaCli_1.runBackportViaCli)([
            '--repo=backport-org/repo-with-programatically-added-commits',
            `--sha=${sha}`,
            '--branch=7.x',
            `--accessToken=${accessToken}`,
            `--dir=${sandboxPath}`,
            '--dry-run',
        ], { showOra: true });
        expect(output).toContain(commitMessage);
        expect(output).toContain('Dry run complete');
    });
});
async function createAndCommitFile({ commitMessage, files, }) {
    const latestCommitSha = await getLatestCommitSha();
    const treeSha = await createTree(files);
    const commitSha = await createCommit({
        latestCommitSha,
        commitMessage,
        treeSha,
    });
    await updateRef(commitSha);
    return commitSha;
}
async function updateRef(sha) {
    try {
        const res = await octokit.rest.git.updateRef({
            owner: 'backport-org',
            repo: 'repo-with-programatically-added-commits',
            ref: 'heads/main',
            sha,
        });
        return res.data;
    }
    catch (e) {
        console.log(e);
    }
}
async function createCommit({ latestCommitSha, commitMessage, treeSha, }) {
    const res = await octokit.rest.git.createCommit({
        owner: 'backport-org',
        repo: 'repo-with-programatically-added-commits',
        message: commitMessage,
        parents: [latestCommitSha],
        tree: treeSha,
    });
    return res.data.sha;
}
async function createTree(files) {
    const res = await octokit.git.createTree({
        owner: 'backport-org',
        repo: 'repo-with-programatically-added-commits',
        tree: files.map((f) => {
            return {
                path: f.path,
                sha: f.sha,
                mode: '100644',
                type: 'blob',
            };
        }),
    });
    return res.data.sha;
}
async function createBlob(content) {
    const res = await octokit.rest.git.createBlob({
        owner: 'backport-org',
        repo: 'repo-with-programatically-added-commits',
        content: content,
        encoding: 'utf-8',
    });
    return res.data.sha;
}
async function getLatestCommitSha() {
    const res = await octokit.repos.getBranch({
        owner: 'backport-org',
        repo: 'repo-with-programatically-added-commits',
        branch: 'main',
    });
    return res.data.commit.sha;
}
