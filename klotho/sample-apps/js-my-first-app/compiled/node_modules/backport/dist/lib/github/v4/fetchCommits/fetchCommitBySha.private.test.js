"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const getDevAccessToken_1 = require("../../../../test/private/getDevAccessToken");
const apiRequestV4Module = __importStar(require("../apiRequestV4"));
const fetchCommitBySha_1 = require("./fetchCommitBySha");
const accessToken = (0, getDevAccessToken_1.getDevAccessToken)();
describe('fetchCommitBySha', () => {
    describe('snapshot request/response', () => {
        let spy;
        let commit;
        beforeEach(async () => {
            spy = jest.spyOn(apiRequestV4Module, 'apiRequestV4');
            commit = await (0, fetchCommitBySha_1.fetchCommitBySha)({
                repoOwner: 'elastic',
                repoName: 'kibana',
                accessToken,
                sha: 'd421ddcf6157150596581c7885afa3690cec6339',
                sourceBranch: 'main',
            });
        });
        it('makes the right queries', () => {
            const queries = spy.mock.calls.reduce((acc, call) => {
                const query = call[0].query;
                //@ts-expect-error
                const name = query.definitions[0].name.value;
                return { ...acc, [name]: (0, graphql_1.print)(query) };
            }, {});
            const queryNames = Object.keys(queries);
            expect(queryNames).toEqual(['CommitsBySha']);
            queryNames.forEach((name) => {
                expect(queries[name]).toMatchSnapshot(`Query: ${name}`);
            });
        });
        it('returns the correct response', async () => {
            expect(commit).toMatchSnapshot();
        });
    });
    it('should return single commit with pull request', async () => {
        const expectedCommit = {
            author: { email: 'sorenlouv@gmail.com', name: 'SÃ¸ren Louv-Jansen' },
            suggestedTargetBranches: [],
            sourceCommit: {
                branchLabelMapping: {
                    '^v(\\d+).(\\d+).\\d+$': '$1.$2',
                    '^v7.9.0$': '7.x',
                    '^v8.0.0$': 'master',
                },
                committedDate: '2020-07-07T20:40:28Z',
                message: '[APM] Add API tests (#70740)',
                sha: 'cb6fbc0e1b406675724181a3e9f59459b5f8f892',
            },
            sourcePullRequest: {
                number: 70740,
                url: 'https://github.com/elastic/kibana/pull/70740',
                mergeCommit: {
                    message: '[APM] Add API tests (#70740)',
                    sha: 'cb6fbc0e1b406675724181a3e9f59459b5f8f892',
                },
            },
            sourceBranch: 'master',
            pullRequestStates: [
                {
                    branch: '7.x',
                    label: 'v7.9.0',
                    isSourceBranch: false,
                    state: 'MERGED',
                    number: 71014,
                    url: 'https://github.com/elastic/kibana/pull/71014',
                    mergeCommit: {
                        message: '[APM] Add API tests (#70740) (#71014)',
                        sha: 'd15242be682582e58cd69f6b7707565434e99293',
                    },
                },
            ],
        };
        await expect(await (0, fetchCommitBySha_1.fetchCommitBySha)({
            repoOwner: 'elastic',
            repoName: 'kibana',
            accessToken,
            sha: 'cb6fbc0',
            sourceBranch: 'master',
        })).toEqual(expectedCommit);
    });
    it('throws if sha does not exist', async () => {
        await expect((0, fetchCommitBySha_1.fetchCommitBySha)({
            repoOwner: 'elastic',
            repoName: 'kibana',
            accessToken,
            sha: 'fc22f59',
            sourceBranch: 'main',
        })).rejects.toThrowError('No commit found on branch "main" with sha "fc22f59"');
    });
    it('throws if sha is invalid', async () => {
        await expect((0, fetchCommitBySha_1.fetchCommitBySha)({
            repoOwner: 'elastic',
            repoName: 'kibana',
            accessToken,
            sha: 'myCommitSha',
            sourceBranch: 'main',
        })).rejects.toThrowError('No commit found on branch "main" with sha "myCommitSha"');
    });
});
