"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_tag_1 = __importDefault(require("graphql-tag"));
const nock_1 = __importDefault(require("nock"));
const nockHelpers_1 = require("../../../test/nockHelpers");
const BackportError_1 = require("../../BackportError");
const apiRequestV4_1 = require("./apiRequestV4");
describe('apiRequestV4', () => {
    afterEach(() => {
        nock_1.default.cleanAll();
    });
    describe('when request succeeds', () => {
        let res;
        let commitsByAuthorCalls;
        beforeEach(async () => {
            commitsByAuthorCalls = (0, nockHelpers_1.mockGqlRequest)({
                name: 'MyQuery',
                statusCode: 200,
                body: { data: { viewer: { login: 'sqren' } } },
            });
            res = await (0, apiRequestV4_1.apiRequestV4)({
                accessToken: 'myAccessToken',
                githubApiBaseUrlV4: 'http://localhost/graphql',
                query: (0, graphql_tag_1.default) `
          query MyQuery {
            viewer {
              login
            }
          }
        `,
                variables: { foo: 'bar' },
            });
        });
        it('should return correct response', async () => {
            expect(res).toEqual({ viewer: { login: 'sqren' } });
        });
        it('should call with correct args', async () => {
            expect(commitsByAuthorCalls).toMatchInlineSnapshot(`
        Array [
          Object {
            "query": "query MyQuery {
          viewer {
            login
          }
        }",
            "variables": Object {
              "foo": "bar",
            },
          },
        ]
      `);
        });
    });
    describe('when request fails with error messages', () => {
        beforeEach(() => {
            (0, nockHelpers_1.mockGqlRequest)({
                name: 'MyQuery',
                statusCode: 200,
                body: {
                    errors: [{ message: 'some error' }, { message: 'some other error' }],
                },
            });
        });
        it('should return error containing the error messages', async () => {
            return expect((0, apiRequestV4_1.apiRequestV4)({
                accessToken: 'myAccessToken',
                githubApiBaseUrlV4: 'http://localhost/graphql',
                query: (0, graphql_tag_1.default) `
            query MyQuery {
              viewer {
                login
              }
            }
          `,
                variables: {
                    foo: 'bar',
                },
            })).rejects.toThrowError(new BackportError_1.BackportError(`some error,some other error (Github API v4)`));
        });
    });
    describe('when request fails without error messages', () => {
        beforeEach(() => {
            (0, nockHelpers_1.mockGqlRequest)({
                name: 'MyQuery',
                statusCode: 500,
                body: { data: { foo: 'bar' } },
            });
        });
        it('should return parsed github error', async () => {
            return expect((0, apiRequestV4_1.apiRequestV4)({
                accessToken: 'myAccessToken',
                githubApiBaseUrlV4: 'http://localhost/graphql',
                query: (0, graphql_tag_1.default) `
            query MyQuery {
              viewer {
                login
              }
            }
          `,
                variables: {
                    foo: 'bar',
                },
            })).rejects.toThrowError('Request failed with status code 500');
        });
    });
});
