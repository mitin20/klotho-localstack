"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cherrypickAndCreateTargetPullRequest = void 0;
const chalk_1 = __importDefault(require("chalk"));
const lodash_1 = require("lodash");
const BackportError_1 = require("./BackportError");
const author_1 = require("./author");
const child_process_promisified_1 = require("./child-process-promisified");
const env_1 = require("./env");
const getCommitsWithoutBackports_1 = require("./getCommitsWithoutBackports");
const git_1 = require("./git");
const commitFormatters_1 = require("./github/commitFormatters");
const addAssigneesToPullRequest_1 = require("./github/v3/addAssigneesToPullRequest");
const addLabelsToPullRequest_1 = require("./github/v3/addLabelsToPullRequest");
const addReviewersToPullRequest_1 = require("./github/v3/addReviewersToPullRequest");
const createPullRequest_1 = require("./github/v3/createPullRequest");
const enablePullRequestAutoMerge_1 = require("./github/v4/enablePullRequestAutoMerge");
const fetchCommitBySha_1 = require("./github/v4/fetchCommits/fetchCommitBySha");
const logger_1 = require("./logger");
const ora_1 = require("./ora");
const prompts_1 = require("./prompts");
const sequentially_1 = require("./sequentially");
function getSourceBranchFromCommits(commits) {
    // sourceBranch should be the same for all commits, so picking `sourceBranch` from the first commit should be fine ðŸ¤ž
    // this is specifically needed when backporting a PR like `backport --pr 123` and the source PR was merged to a non-default (aka non-master) branch.
    const { sourceBranch } = commits[0];
    return sourceBranch;
}
async function cherrypickAndCreateTargetPullRequest({ options, commits, targetBranch, }) {
    const backportBranch = getBackportBranchName(targetBranch, commits);
    const repoForkOwner = (0, git_1.getRepoForkOwner)(options);
    (0, logger_1.consoleLog)(`\n${chalk_1.default.bold(`Backporting to ${targetBranch}:`)}`);
    const sourceBranch = getSourceBranchFromCommits(commits);
    const [gitConfigAuthor] = await Promise.all([
        (0, author_1.getGitConfigAuthor)(options),
        (0, git_1.createBackportBranch)({
            options,
            sourceBranch,
            targetBranch,
            backportBranch,
        }),
    ]);
    const commitsFlattened = (0, lodash_1.flatten)(await Promise.all(commits.map((c) => getMergeCommits(options, c))));
    await (0, sequentially_1.sequentially)(commitsFlattened, (commit) => waitForCherrypick(options, commit, targetBranch, gitConfigAuthor));
    if (options.dryRun) {
        (0, ora_1.ora)(options.interactive).succeed('Dry run complete');
        return { url: 'https://localhost/dry-run', didUpdate: false, number: 1337 };
    }
    await (0, git_1.pushBackportBranch)({ options, backportBranch });
    await (0, git_1.deleteBackportBranch)({ options, backportBranch });
    const prPayload = {
        owner: options.repoOwner,
        repo: options.repoName,
        title: (0, createPullRequest_1.getTitle)({ options, commits, targetBranch }),
        body: (0, createPullRequest_1.getPullRequestBody)({ options, commits, targetBranch }),
        head: `${repoForkOwner}:${backportBranch}`,
        base: targetBranch, // eg. 7.x
    };
    const targetPullRequest = await (0, createPullRequest_1.createPullRequest)({ options, prPayload });
    // add assignees to target pull request
    const assignees = options.autoAssign
        ? [options.authenticatedUsername]
        : options.assignees;
    if (options.assignees.length > 0) {
        await (0, addAssigneesToPullRequest_1.addAssigneesToPullRequest)(options, targetPullRequest.number, assignees);
    }
    // add reviewers to target pull request
    if (options.reviewers.length > 0) {
        await (0, addReviewersToPullRequest_1.addReviewersToPullRequest)(options, targetPullRequest.number, options.reviewers);
    }
    // add labels to target pull request
    if (options.targetPRLabels.length > 0) {
        await (0, addLabelsToPullRequest_1.addLabelsToPullRequest)(options, targetPullRequest.number, options.targetPRLabels);
    }
    // make PR auto mergable
    if (options.autoMerge) {
        await (0, enablePullRequestAutoMerge_1.enablePullRequestAutoMerge)(options, targetPullRequest.number);
    }
    // add labels to source pull requests
    if (options.sourcePRLabels.length > 0) {
        const promises = commits.map((commit) => {
            if (commit.sourcePullRequest) {
                return (0, addLabelsToPullRequest_1.addLabelsToPullRequest)(options, commit.sourcePullRequest.number, options.sourcePRLabels);
            }
        });
        await Promise.all(promises);
    }
    (0, logger_1.consoleLog)(`View pull request: ${targetPullRequest.url}`);
    return targetPullRequest;
}
exports.cherrypickAndCreateTargetPullRequest = cherrypickAndCreateTargetPullRequest;
async function getMergeCommits(options, commit) {
    const { sha } = commit.sourceCommit;
    if (!options.mainline) {
        const isMergeCommit = await (0, git_1.getIsMergeCommit)(options, sha);
        if (isMergeCommit) {
            const shas = await (0, git_1.getShasInMergeCommit)(options, sha);
            return Promise.all(shas.reverse().map((sha) => (0, fetchCommitBySha_1.fetchCommitBySha)({ ...options, sha })));
        }
    }
    return [commit];
}
/*
 * Returns the name of the backport branch without remote name
 *
 * Examples:
 * For a single PR: `backport/7.x/pr-1234`
 * For a single commit: `backport/7.x/commit-abcdef`
 * For multiple: `backport/7.x/pr-1234_commit-abcdef`
 */
function getBackportBranchName(targetBranch, commits) {
    const refValues = commits
        .map((commit) => commit.sourcePullRequest
        ? `pr-${commit.sourcePullRequest.number}`
        : `commit-${(0, commitFormatters_1.getShortSha)(commit.sourceCommit.sha)}`)
        .join('_')
        .slice(0, 200);
    return `backport/${targetBranch}/${refValues}`;
}
async function waitForCherrypick(options, commit, targetBranch, gitConfigAuthor) {
    const spinnerText = `Cherry-picking: ${chalk_1.default.greenBright((0, commitFormatters_1.getFirstLine)(commit.sourceCommit.message))}`;
    const cherrypickSpinner = (0, ora_1.ora)(options.interactive, spinnerText).start();
    const commitAuthor = (0, author_1.getCommitAuthor)({ options, commit, gitConfigAuthor });
    await cherrypickAndHandleConflicts({
        options,
        commit,
        commitAuthor,
        targetBranch,
        cherrypickSpinner,
    });
    // Conflicts should be resolved and files staged at this point
    try {
        // Run `git commit` in case conflicts were not manually committed
        await (0, git_1.commitChanges)({ options, commit, commitAuthor });
        cherrypickSpinner.succeed();
    }
    catch (e) {
        cherrypickSpinner.fail();
        throw e;
    }
}
async function cherrypickAndHandleConflicts({ options, commit, commitAuthor, targetBranch, cherrypickSpinner, }) {
    const mergedTargetPullRequest = commit.pullRequestStates.find((pr) => pr.state === 'MERGED' && pr.branch === targetBranch);
    let conflictingFiles;
    let unstagedFiles;
    let needsResolving;
    try {
        ({ conflictingFiles, unstagedFiles, needsResolving } = await (0, git_1.cherrypick)({
            options,
            sha: commit.sourceCommit.sha,
            mergedTargetPullRequest,
            commitAuthor,
        }));
        // no conflicts encountered
        if (!needsResolving) {
            return;
        }
        // cherrypick failed due to conflicts
        cherrypickSpinner.fail();
    }
    catch (e) {
        cherrypickSpinner.fail();
        throw e;
    }
    const repoPath = (0, env_1.getRepoPath)(options);
    // resolve conflicts automatically
    if (options.autoFixConflicts) {
        const autoResolveSpinner = (0, ora_1.ora)(options.interactive, 'Attempting to resolve conflicts automatically').start();
        const didAutoFix = await options.autoFixConflicts({
            files: conflictingFiles.map((f) => f.absolute),
            directory: repoPath,
            logger: logger_1.logger,
            targetBranch,
        });
        // conflicts were automatically resolved
        if (didAutoFix) {
            autoResolveSpinner.succeed();
            return;
        }
        autoResolveSpinner.fail();
    }
    const conflictingFilesRelative = conflictingFiles
        .map((f) => f.relative)
        .slice(0, 50);
    const commitsWithoutBackports = await (0, getCommitsWithoutBackports_1.getCommitsWithoutBackports)({
        options,
        commit,
        targetBranch,
        conflictingFiles: conflictingFilesRelative,
    });
    if (!options.interactive) {
        throw new BackportError_1.BackportError({
            code: 'merge-conflict-exception',
            commitsWithoutBackports,
            conflictingFiles: conflictingFilesRelative,
        });
    }
    (0, logger_1.consoleLog)(chalk_1.default.bold('\nThe commit could not be backported due to conflicts\n'));
    (0, logger_1.consoleLog)(`Please fix the conflicts in ${repoPath}`);
    if (commitsWithoutBackports.length > 0) {
        (0, logger_1.consoleLog)(chalk_1.default.italic(`Hint: Before fixing the conflicts manually you should consider backporting the following pull requests to "${targetBranch}":`));
        (0, logger_1.consoleLog)(`${commitsWithoutBackports.map((c) => c.formatted).join('\n')}\n\n`);
    }
    /*
     * Commit could not be cleanly cherrypicked: Initiating conflict resolution
     */
    if (options.editor) {
        await (0, child_process_promisified_1.spawnPromise)(options.editor, [repoPath], options.cwd);
    }
    // list files with conflict markers + unstaged files and require user to resolve them
    await listConflictingAndUnstagedFiles({
        retries: 0,
        options,
        conflictingFiles: conflictingFiles.map((f) => f.absolute),
        unstagedFiles,
    });
}
async function listConflictingAndUnstagedFiles({ retries, options, conflictingFiles, unstagedFiles, }) {
    const hasUnstagedFiles = !(0, lodash_1.isEmpty)((0, lodash_1.difference)(unstagedFiles, conflictingFiles));
    const hasConflictingFiles = !(0, lodash_1.isEmpty)(conflictingFiles);
    if (!hasConflictingFiles && !hasUnstagedFiles) {
        return;
    }
    // add divider between prompts
    if (retries > 0) {
        (0, logger_1.consoleLog)('\n----------------------------------------\n');
    }
    const header = chalk_1.default.reset(`Fix the following conflicts manually:`);
    // show conflict section if there are conflicting files
    const conflictSection = hasConflictingFiles
        ? `Conflicting files:\n${chalk_1.default.reset(conflictingFiles.map((file) => ` - ${file}`).join('\n'))}`
        : '';
    const unstagedSection = hasUnstagedFiles
        ? `Unstaged files:\n${chalk_1.default.reset(unstagedFiles.map((file) => ` - ${file}`).join('\n'))}`
        : '';
    const didConfirm = await (0, prompts_1.confirmPrompt)(`${header}\n\n${conflictSection}\n${unstagedSection}\n\nPress ENTER when the conflicts are resolved and files are staged`);
    if (!didConfirm) {
        throw new BackportError_1.BackportError({ code: 'abort-conflict-resolution-exception' });
    }
    const MAX_RETRIES = 100;
    if (retries++ > MAX_RETRIES) {
        throw new Error(`Maximum number of retries (${MAX_RETRIES}) exceeded`);
    }
    const [_conflictingFiles, _unstagedFiles] = await Promise.all([
        (0, git_1.getConflictingFiles)(options),
        (0, git_1.getUnstagedFiles)(options),
    ]);
    await listConflictingAndUnstagedFiles({
        retries,
        options,
        conflictingFiles: _conflictingFiles.map((file) => file.absolute),
        unstagedFiles: _unstagedFiles,
    });
}
