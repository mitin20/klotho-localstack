"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.confirmPrompt = exports.promptForTargetBranches = exports.promptForCommits = exports.getChoicesForCommitPrompt = void 0;
const chalk_1 = __importDefault(require("chalk"));
const inquirer_1 = __importDefault(require("inquirer"));
const lodash_1 = require("lodash");
const terminal_link_1 = __importDefault(require("terminal-link"));
const commitFormatters_1 = require("./github/commitFormatters");
async function prompt(options) {
    const { promptResult } = (await inquirer_1.default.prompt([
        { ...options, name: 'promptResult' },
    ]));
    return promptResult;
}
function getPrStateIcon(state) {
    if (state === 'MERGED') {
        return 'ðŸŸ¢';
    }
    if (state === 'NOT_CREATED') {
        return 'ðŸ”´';
    }
    if (state === 'OPEN') {
        return 'ðŸ”µ';
    }
    // unknown state
    return 'ðŸ”´';
}
function getPrStateText(state) {
    if (state === 'MERGED') {
        return chalk_1.default.gray('Merged');
    }
    if (state === 'NOT_CREATED') {
        return chalk_1.default.gray('Backport not created');
    }
    if (state === 'OPEN') {
        return chalk_1.default.gray('Open, not merged');
    }
    return chalk_1.default.gray('Unknown state');
}
function getPrLink(number, url) {
    return url ? `(${(0, terminal_link_1.default)(`#${number}`, url)})` : '';
}
function getDetailedPullStatus(c) {
    const items = c.pullRequestStates
        .filter(({ isSourceBranch }) => !isSourceBranch)
        .map((pr) => {
        const prLink = getPrLink(pr.number, pr.url);
        return `     â”” ${getPrStateIcon(pr.state)} ${pr.branch} ${prLink} ${getPrStateText(pr.state)}`;
    });
    const list = items.length > 0
        ? `\n${chalk_1.default.reset(items.join('\n'))}`
        : `\n     â”” ${chalk_1.default.gray('No backports expected')}`;
    return `${list}\n`;
}
function getSimplePullStatus(c) {
    return c.pullRequestStates
        .filter(({ isSourceBranch }) => !isSourceBranch)
        .map(({ state, branch }) => {
        if (state === 'MERGED') {
            return chalk_1.default.green(branch);
        }
        if (state === 'NOT_CREATED') {
            return chalk_1.default.red(branch);
        }
        if (state === 'OPEN') {
            return chalk_1.default.gray(branch);
        }
        return chalk_1.default.gray('Unknown state');
    })
        .join(', ');
}
function getChoicesForCommitPrompt(commits, showDetails) {
    return commits.map((c, i) => {
        const leadingWhitespace = (0, lodash_1.repeat)(' ', 2 - (i + 1).toString().length);
        const position = chalk_1.default.gray(`${i + 1}.${leadingWhitespace}`);
        let name;
        if (showDetails) {
            const message = (0, commitFormatters_1.stripPullNumber)(c.sourceCommit.message);
            const prLink = c.sourcePullRequest
                ? ` ` + getPrLink(c.sourcePullRequest.number, c.sourcePullRequest.url)
                : '';
            const pullStatus = getDetailedPullStatus(c);
            name = `${position}${message}${prLink}${pullStatus}`;
        }
        else {
            const message = (0, commitFormatters_1.getFirstLine)(c.sourceCommit.message);
            const pullStatus = getSimplePullStatus(c);
            name = `${position}${message} ${pullStatus}`;
        }
        const short = c.sourcePullRequest
            ? `#${c.sourcePullRequest.number} (${(0, commitFormatters_1.getShortSha)(c.sourcePullRequest.mergeCommit.sha)})`
            : (0, commitFormatters_1.getShortSha)(c.sourceCommit.sha);
        return { name, short, value: c };
    });
}
exports.getChoicesForCommitPrompt = getChoicesForCommitPrompt;
async function promptForCommits({ commitChoices, isMultipleChoice, showDetails, }) {
    const choices = getChoicesForCommitPrompt(commitChoices, showDetails);
    const res = await prompt({
        loop: false,
        pageSize: 30,
        choices: choices,
        message: 'Select commit',
        type: isMultipleChoice ? 'checkbox' : 'list',
    });
    const selectedCommits = Array.isArray(res) ? res.reverse() : [res];
    return (0, lodash_1.isEmpty)(selectedCommits)
        ? promptForCommits({ commitChoices, isMultipleChoice, showDetails })
        : selectedCommits;
}
exports.promptForCommits = promptForCommits;
async function promptForTargetBranches({ targetBranchChoices, isMultipleChoice, }) {
    const res = await prompt({
        loop: false,
        pageSize: 15,
        choices: targetBranchChoices,
        message: 'Select branch',
        type: isMultipleChoice ? 'checkbox' : 'list',
    });
    const selectedBranches = Array.isArray(res) ? res : [res];
    return (0, lodash_1.isEmpty)(selectedBranches)
        ? promptForTargetBranches({
            targetBranchChoices,
            isMultipleChoice,
        })
        : selectedBranches;
}
exports.promptForTargetBranches = promptForTargetBranches;
function confirmPrompt(message) {
    return prompt({ message, type: 'confirm' });
}
exports.confirmPrompt = confirmPrompt;
