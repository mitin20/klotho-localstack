"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = __importDefault(require("fs/promises"));
const find_up_1 = __importDefault(require("find-up"));
const projectConfig_1 = require("./projectConfig");
describe('getProjectConfig', () => {
    afterEach(() => jest.clearAllMocks());
    describe('deprecations', () => {
        describe('when specifying deprecated `branches`', () => {
            it('is returned as `targetBranchChoices`', async () => {
                jest.spyOn(promises_1.default, 'readFile').mockResolvedValueOnce(JSON.stringify({
                    repoName: 'kibana',
                    repoOwner: 'elastic',
                    branches: ['6.x'],
                }));
                const projectConfig = await (0, projectConfig_1.getProjectConfig)({
                    projectConfigFile: undefined,
                });
                expect(projectConfig?.targetBranchChoices).toEqual(['6.x']);
            });
        });
        describe('when specifying deprecated `labels`', () => {
            it('is returned as `targetPRLabels`', async () => {
                jest.spyOn(promises_1.default, 'readFile').mockResolvedValueOnce(JSON.stringify({
                    labels: ['backport'],
                }));
                const projectConfig = await (0, projectConfig_1.getProjectConfig)({
                    projectConfigFile: undefined,
                });
                expect(projectConfig?.targetPRLabels).toEqual(['backport']);
            });
        });
        describe('when specifying deprecated `upstream`', () => {
            it('is split into `repoOwner` and `repoName`', async () => {
                jest.spyOn(promises_1.default, 'readFile').mockResolvedValueOnce(JSON.stringify({
                    upstream: 'elastic/kibana',
                }));
                const projectConfig = await (0, projectConfig_1.getProjectConfig)({
                    projectConfigFile: undefined,
                });
                expect(projectConfig?.repoOwner).toEqual('elastic');
                expect(projectConfig?.repoName).toEqual('kibana');
            });
        });
        describe('when projectConfig is valid', () => {
            let projectConfig;
            beforeEach(async () => {
                jest.spyOn(promises_1.default, 'readFile').mockResolvedValueOnce(JSON.stringify({
                    repoName: 'kibana',
                    repoOwner: 'elastic',
                    targetBranchChoices: ['6.x'],
                    targetPRLabels: ['backport'],
                }));
                projectConfig = await (0, projectConfig_1.getProjectConfig)({
                    projectConfigFile: undefined,
                });
            });
            it('should call findUp', () => {
                expect(find_up_1.default).toHaveBeenCalledWith('.backportrc.json');
            });
            it('should return config', () => {
                expect(projectConfig).toEqual({
                    repoName: 'kibana',
                    repoOwner: 'elastic',
                    targetBranchChoices: ['6.x'],
                    targetPRLabels: ['backport'],
                });
            });
        });
        describe('when specifying a path to project config', () => {
            let projectConfig;
            let spy;
            beforeEach(async () => {
                spy = jest.spyOn(promises_1.default, 'readFile').mockResolvedValueOnce(JSON.stringify({
                    repoName: 'kibana',
                    repoOwner: 'elastic',
                    targetBranchChoices: ['6.x'],
                    targetPRLabels: ['backport'],
                }));
                projectConfig = await (0, projectConfig_1.getProjectConfig)({
                    projectConfigFile: '/custom/path/to/project/.backportrc.json',
                });
            });
            it('should not call findUp', () => {
                expect(find_up_1.default).not.toHaveBeenCalled();
            });
            it('should retrieve config via custom config path', () => {
                expect(spy).toHaveBeenCalledWith('/custom/path/to/project/.backportrc.json', 'utf8');
            });
            it('should return config', () => {
                expect(projectConfig).toEqual({
                    repoName: 'kibana',
                    repoOwner: 'elastic',
                    targetBranchChoices: ['6.x'],
                    targetPRLabels: ['backport'],
                });
            });
        });
    });
    describe('when projectConfig is empty', () => {
        it('should return empty config', async () => {
            jest.spyOn(promises_1.default, 'readFile').mockResolvedValueOnce('{}');
            const projectConfig = await (0, projectConfig_1.getProjectConfig)({
                projectConfigFile: undefined,
            });
            expect(projectConfig).toEqual({});
        });
    });
    describe('when projectConfig is missing', () => {
        it('should return empty config', async () => {
            find_up_1.default.mockReturnValueOnce(undefined);
            const projectConfig = await (0, projectConfig_1.getProjectConfig)({
                projectConfigFile: undefined,
            });
            expect(projectConfig).toEqual(undefined);
        });
    });
});
