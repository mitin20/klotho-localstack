"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.withConfigMigrations = exports.readConfigFile = void 0;
const promises_1 = require("fs/promises");
const strip_json_comments_1 = __importDefault(require("strip-json-comments"));
const BackportError_1 = require("../../lib/BackportError");
const excludeUndefined_1 = require("../../utils/excludeUndefined");
async function readConfigFile(filepath) {
    const fileContents = await (0, promises_1.readFile)(filepath, 'utf8');
    const configWithoutComments = (0, strip_json_comments_1.default)(fileContents);
    try {
        return withConfigMigrations(JSON.parse(configWithoutComments));
    }
    catch (e) {
        throw new BackportError_1.BackportError(`"${filepath}" contains invalid JSON:\n\n${fileContents}`);
    }
}
exports.readConfigFile = readConfigFile;
// ensure backwards compatability when config options are renamed
function withConfigMigrations({ upstream, labels, branches, ...config }) {
    const { repoName, repoOwner } = parseUpstream(upstream, config);
    return (0, excludeUndefined_1.excludeUndefined)({
        ...config,
        // `branches` was renamed `targetBranchChoices`
        targetBranchChoices: config.targetBranchChoices ?? branches,
        // `upstream` has been renamed to `repoOwner`/`repoName`
        repoName,
        repoOwner,
        // `labels` was renamed `targetPRLabels`
        targetPRLabels: config.targetPRLabels ?? labels,
    });
}
exports.withConfigMigrations = withConfigMigrations;
function parseUpstream(upstream, config) {
    if (upstream) {
        const [repoOwner, repoName] = upstream.split('/');
        return { repoOwner, repoName };
    }
    return {
        repoOwner: config.repoOwner,
        repoName: config.repoName,
    };
}
