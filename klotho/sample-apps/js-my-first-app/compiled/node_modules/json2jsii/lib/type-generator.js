"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeGenerator = void 0;
const camelcase_1 = __importDefault(require("camelcase"));
const snake_case_1 = require("snake-case");
const code_1 = require("./code");
const tojson_1 = require("./tojson");
const PRIMITIVE_TYPES = ['string', 'number', 'integer', 'boolean'];
const DEFINITIONS_PREFIX = '#/definitions/';
const DEFAULT_RENDER_TYPE_NAME = (s) => s.split('.').map(x => pascalCase(x)).join('');
/**
 * Generates typescript types from JSON schemas.
 */
class TypeGenerator {
    /**
     * Convert all-caps acronyms (e.g. "VPC", "FooBARZooFIGoo") to pascal case
     * (e.g. "Vpc", "FooBarZooFiGoo").
     */
    static normalizeTypeName(typeName) {
        // start with the full string and then use the regex to match all-caps sequences.
        const re = /([A-Z]+)(?:[^a-z]|$)/g;
        let result = typeName;
        let m;
        do {
            m = re.exec(typeName);
            if (m) {
                const before = result.slice(0, m.index); // all the text before the sequence
                const cap = m[1]; // group #1 matches the all-caps sequence we are after
                const pascal = cap[0] + cap.slice(1).toLowerCase(); // convert to pascal case by lowercasing all but the first char
                const after = result.slice(m.index + pascal.length); // all the text after the sequence
                result = before + pascal + after; // concat
            }
        } while (m);
        result = result.replace(/^./, result[0].toUpperCase()); // ensure first letter is capitalized
        return result;
    }
    /**
     * Renders a JSII struct (and accompanying types) from a JSON schema.
     *
     * If you wish to render multiple top-level structs or include custom types,
     * create a new instance of `TypeGenerator` manually.
     *
     * @param structName The name of the JSII struct (TypeScript interface).
     * @param schema The JSON schema (top level schema must include "properties")
     * @returns Generated TypeScript source code that includes the top-level
     * struct and all other types.
     */
    static forStruct(structName, schema, options = {}) {
        const gen = new TypeGenerator({ definitions: schema.definitions, ...options });
        gen.emitType(structName, schema);
        return gen;
    }
    /**
     *
     * @param schema Schema definitions
     * @param options
     */
    constructor(options = {}) {
        var _a, _b, _c, _d;
        this.typesToEmit = {};
        this.emittedTypes = {};
        this.exclude = (_a = options.exclude) !== null && _a !== void 0 ? _a : [];
        this.definitions = {};
        this.toJson = (_b = options.toJson) !== null && _b !== void 0 ? _b : true;
        this.renderTypeName = (_c = options.renderTypeName) !== null && _c !== void 0 ? _c : DEFAULT_RENDER_TYPE_NAME;
        for (const [typeName, def] of Object.entries((_d = options.definitions) !== null && _d !== void 0 ? _d : {})) {
            this.addDefinition(typeName, def);
        }
    }
    /**
     * Adds a JSON schema definition for a type name. This method does not emit the type
     * but rather just registers the definition that will get resolved if this type is `$ref`ed.
     *
     * @param typeName The name of the type.
     * @param def The JSON schema definition for this type
     */
    addDefinition(typeName, def) {
        this.definitions[typeName] = def;
    }
    /**
     * Overrides the definition of `fromTypeName` such that any references to it
     * will be resolved as `toTypeName`. Bear in mind that the type name specified
     * in `to` must either be defined as a definition (`addDefinition()`) _or_
     * emitted as a custom type (`emitCustomType()`).
     */
    addAlias(from, to) {
        this.addDefinition(from, { $ref: `#/definitions/${to}` });
    }
    /**
     * Emit a type based on a JSON schema. If `def` is not specified, the
     * definition of the type will be looked up in the `definitions` provided
     * during initialization or via `addDefinition()`.
     *
     * @param typeName The name of th type
     * @param def JSON schema. If not specified, the schema is looked up from
     * `definitions` based on the type name
     * @param structFqn FQN for the type (defaults to `typeName`)
     * @returns The resolved type (not always the same as `typeName`)
     */
    emitType(typeName, def, structFqn = typeName) {
        return this.emitTypeInternal(typeName, def, structFqn).type;
    }
    /**
     * Emit a type based on a JSON schema. If `def` is not specified, the
     * definition of the type will be looked up in the `definitions` provided
     * during initialization or via `addDefinition()`.
     *
     * @param typeName The name of th type
     * @param def JSON schema. If not specified, the schema is looked up from
     * `definitions` based on the type name
     * @param structFqn FQN for the type (defaults to `typeName`)
     * @returns The resolved type (not always the same as `typeName`)
     */
    emitTypeInternal(typeName, def, structFqn = typeName) {
        if (!def) {
            def = this.definitions[typeName];
            if (!def) {
                throw new Error(`unable to find schema definition for ${typeName}`);
            }
        }
        // callers expect that emit a type named `typeName` so we can't change it here
        // but at least we can verify it's correct.
        if (TypeGenerator.normalizeTypeName(typeName) !== typeName) {
            throw new Error(`${typeName} must be normalized before calling emitType`);
        }
        if (structFqn.startsWith(DEFINITIONS_PREFIX)) {
            structFqn = structFqn.substring(DEFINITIONS_PREFIX.length);
        }
        if (this.isExcluded(structFqn)) {
            throw new Error(`Type ${structFqn} cannot be added since it matches one of the exclusion patterns`);
        }
        // complex type
        if (def.$ref) {
            return this.typeForRef(def);
        }
        // unions (unless this is a struct, and then we just ignore the constraints)
        if (def.oneOf || def.anyOf) {
            const asUnion = this.tryEmitUnion(typeName, def, structFqn);
            if (asUnion) {
                return asUnion;
            }
            // carry on, we can't represent this schema as a union (yet?)
        }
        // dates
        if (def.format === 'date-time') {
            if (def.type && def.type !== 'string') {
                throw new Error('date-time must be a string');
            }
            return { type: 'Date', toJson: x => `${x}?.toISOString()` };
        }
        // enums
        if (def.enum && Array.isArray(def.enum) && def.enum.length > 0 && def.enum.every(x => ['string', 'number'].includes(typeof (x)))) {
            if (def.type && !(def.type === 'string' || def.type === 'number' || def.type === 'integer')) {
                throw new Error('only enums with string or number values are supported');
            }
            return this.emitEnum(typeName, def, structFqn);
        }
        // struct
        if (def.properties) {
            if (def.type && def.type !== 'object') {
                throw new Error('for "properties", if "type" is specified it has to be an "object"');
            }
            return this.emitStruct(typeName, def, structFqn);
        }
        // map
        if (def.additionalProperties && typeof (def.additionalProperties) === 'object') {
            if (def.type && def.type !== 'object') {
                throw new Error('for "additionalProperties", if "type" is specified it has to be an "object"');
            }
            const et = this.typeForProperty(typeName, def.additionalProperties);
            const toJson = (x) => `((${x}) === undefined) ? undefined : (Object.entries(${x}).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: ${et.toJson('i[1]')} }), {}))`;
            return { type: `{ [key: string]: ${et.type} }`, toJson };
        }
        switch (def.type) {
            case 'string':
                return { type: 'string', toJson: x => x };
            case 'number':
            case 'integer':
                return { type: 'number', toJson: x => x };
            case 'boolean':
                return { type: 'boolean', toJson: (x) => x };
            case 'array': {
                return this.emitArray(typeName, def);
            }
        }
        return { type: 'any', toJson: x => x };
    }
    /**
     * Registers a custom type and emits it. This will override any existing
     * definitions for this type name.
     *
     * @param typeName The name of the type emitted by this handler.
     * @param emitter A function that will be called to emit the code and returns
     * information about the emitted type.
     */
    emitCustomType(typeName, emitter) {
        if (typeName in this.emittedTypes) {
            return;
        }
        this.typesToEmit[typeName] = code => {
            const result = emitter(code);
            if (typeof (result) === 'object') {
                return result;
            }
            else {
                return { type: typeName, toJson: x => x };
            }
        };
    }
    /**
     * @deprecated use `emitCustomType()`
     */
    addCode(typeName, emitter) {
        return this.emitCustomType(typeName, emitter);
    }
    /**
     * Renders all emitted types to a string.
     *
     * Use `renderToCode()` in order to render output to an existing `Code` object.
     */
    render() {
        const code = new code_1.Code();
        this.renderToCode(code);
        return code.render();
    }
    /**
     * Writes all types to a `CodeMaker` with an open file.
     * Use this method in case you need to add those type to an existing file.
     * @param code The `CodeMaker` instance.
     */
    renderToCode(code) {
        while (Object.keys(this.typesToEmit).length) {
            const name = Object.keys(this.typesToEmit)[0];
            const emitter = this.typesToEmit[name];
            const emittedType = emitter(code);
            code.line();
            delete this.typesToEmit[name];
            this.emittedTypes[name] = emittedType;
        }
    }
    /**
     * @deprecated use `renderToCode()`
     */
    emitCode(code) {
        return this.renderToCode(code);
    }
    /**
     * @deprecated use `emitType()`
     */
    addType(typeName, def, structFqn = typeName) {
        return this.emitType(typeName, def, structFqn);
    }
    /**
     * Emits an array.
     */
    emitArray(typeName, def) {
        const et = this.typeForArray(typeName, def);
        return { type: `${et.type}[]`, toJson: x => `${x}?.map(y => ${et.toJson('y')})` };
    }
    /**
     * @returns true if this definition can be represented as a union or false if it cannot
     */
    tryEmitUnion(typeName, def, fqn) {
        const options = new Array();
        for (const option of def.oneOf || def.anyOf || []) {
            if (!supportedUnionOptionType(option.type)) {
                return undefined;
            }
            const type = option.type === 'integer' ? 'number' : option.type;
            options.push(type);
        }
        const emitted = { type: typeName, toJson: x => `${x}?.value` };
        this.addCode(typeName, code => {
            this.emitDescription(code, fqn, def.description);
            code.openBlock(`export class ${typeName}`);
            const possibleTypes = [];
            for (const type of options) {
                possibleTypes.push(type);
                const methodName = 'from' + type[0].toUpperCase() + type.substr(1);
                code.openBlock(`public static ${methodName}(value: ${type}): ${typeName}`);
                code.line(`return new ${typeName}(value);`);
                code.closeBlock();
            }
            code.openBlock(`private constructor(public readonly value: ${possibleTypes.join(' | ')})`);
            code.closeBlock();
            code.closeBlock();
            return emitted;
        });
        return emitted;
    }
    emitStruct(typeName, structDef, structFqn) {
        const toJson = new tojson_1.ToJsonFunction(typeName);
        const emitted = {
            type: typeName,
            toJson: x => `${toJson.functionName}(${x})`,
        };
        this.emitCustomType(typeName, code => {
            this.emitDescription(code, structFqn, structDef.description);
            code.openBlock(`export interface ${typeName}`);
            for (const [propName, propSpec] of Object.entries(structDef.properties || {})) {
                this.emitProperty(code, propName, propSpec, structFqn, structDef, toJson);
            }
            code.closeBlock();
            if (this.toJson) {
                toJson.emit(code);
            }
            return emitted;
        });
        return emitted;
    }
    emitProperty(code, name, propDef, structFqn, structDef, toJson) {
        const originalName = name;
        // if the name starts with '$' (like $ref or $schema), we remove the "$"
        // and it's the same deal - will produce invalid output
        if (name.startsWith('$')) {
            name = name.substring(1);
        }
        // convert the name to camel case so it's compatible with JSII
        name = (0, camelcase_1.default)(name);
        this.emitDescription(code, `${structFqn}#${originalName}`, propDef.description);
        const propertyType = this.typeForProperty(`${structFqn}.${name}`, propDef);
        const required = this.isPropertyRequired(originalName, structDef);
        const optional = required ? '' : '?';
        code.line(`readonly ${name}${optional}: ${propertyType.type};`);
        code.line();
        toJson.addField(originalName, name, propertyType.toJson);
    }
    emitEnum(typeName, def, structFqn) {
        const emitted = {
            type: typeName,
            toJson: x => x,
        };
        this.emitCustomType(typeName, code => {
            if (!def.enum || def.enum.length === 0) {
                throw new Error(`definition is not an enum: ${JSON.stringify(def)}`);
            }
            if (def.type && !(def.type === 'string' || def.type === 'number' || def.type === 'integer')) {
                throw new Error('only enums with string or number values are supported');
            }
            this.emitDescription(code, structFqn, def.description);
            code.openBlock(`export enum ${typeName}`);
            for (const value of def.enum) {
                if (!['string', 'number'].includes(typeof (value))) {
                    throw new Error('only enums with string or number values are supported');
                }
                // sluggify and turn to UPPER_SNAKE_CASE
                let memberName = (0, snake_case_1.snakeCase)(`${value}`.replace(/[^a-z0-9]/gi, '_')).split('_').filter(x => x).join('_').toUpperCase();
                // if member name starts with a non-alpha character, add a prefix so it becomes a symbol
                if (!/^[A-Z].*/i.test(memberName)) {
                    memberName = 'VALUE_' + memberName;
                }
                code.line(`/** ${value} */`);
                code.line(`${memberName} = ${JSON.stringify(value)},`);
            }
            code.closeBlock();
            return emitted;
        });
        return emitted;
    }
    emitDescription(code, fqn, description, annotations = {}) {
        code.line('/**');
        if (description) {
            description = description.replace(/\*\//g, '_/');
            for (const dline of description.split('\n').map(x => x.trim())) {
                code.line(` * ${dline}`);
            }
            const extractDefault = /Defaults?\W+(to|is)\W+(.+)/g.exec(description);
            const def = extractDefault && extractDefault[2];
            if (def) {
                annotations.default = def;
            }
            code.line(' *');
        }
        annotations.schema = fqn;
        for (const [type, value] of Object.entries(annotations)) {
            code.line(` * @${type} ${value}`);
        }
        code.line(' */');
    }
    typeForProperty(propertyFqn, def) {
        const subtype = TypeGenerator.normalizeTypeName(DEFAULT_RENDER_TYPE_NAME(propertyFqn));
        return this.emitTypeInternal(subtype, def, subtype);
    }
    typeForRef(def) {
        const prefix = '#/definitions/';
        if (!def.$ref || !def.$ref.startsWith(prefix)) {
            throw new Error(`invalid $ref ${JSON.stringify(def)}`);
        }
        if (this.isExcluded(def.$ref)) {
            return { type: 'any', toJson: x => x };
        }
        const typeName = TypeGenerator.normalizeTypeName(this.renderTypeName(def.$ref.substring(prefix.length)));
        // if we already emitted a type with this type name, just return it
        const emitted = this.emittedTypes[typeName];
        if (emitted) {
            return emitted;
        }
        const schema = this.resolveReference(def);
        return this.emitTypeInternal(typeName, schema, def.$ref);
    }
    typeForArray(propertyFqn, def) {
        if (!def.items || typeof (def.items) !== 'object') {
            throw new Error(`unsupported array type ${def.items}`);
        }
        return this.typeForProperty(propertyFqn, def.items);
    }
    resolveReference(def) {
        const ref = def.$ref;
        if (!ref || !ref.startsWith(DEFINITIONS_PREFIX)) {
            throw new Error('expecting a local reference');
        }
        const lookup = ref.substr(DEFINITIONS_PREFIX.length);
        const found = this.definitions[lookup];
        if (!found) {
            throw new Error(`unable to find a definition for the $ref "${lookup}"`);
        }
        return found;
    }
    isPropertyRequired(property, structDef) {
        return Array.isArray(structDef.required) && structDef.required.includes(property);
    }
    isExcluded(fqn) {
        for (const pattern of this.exclude) {
            const re = new RegExp(pattern);
            if (re.test(fqn)) {
                return true;
            }
        }
        return false;
    }
}
exports.TypeGenerator = TypeGenerator;
function supportedUnionOptionType(type) {
    return type && (typeof (type) === 'string' && PRIMITIVE_TYPES.includes(type));
}
function pascalCase(s) {
    return (0, camelcase_1.default)(s, { pascalCase: true });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS1nZW5lcmF0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdHlwZS1nZW5lcmF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsMERBQWtDO0FBRWxDLDJDQUF1QztBQUN2QyxpQ0FBOEI7QUFDOUIscUNBQTBDO0FBRzFDLE1BQU0sZUFBZSxHQUFHLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDbkUsTUFBTSxrQkFBa0IsR0FBRyxnQkFBZ0IsQ0FBQztBQUM1QyxNQUFNLHdCQUF3QixHQUFHLENBQUMsQ0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQTZDOUY7O0dBRUc7QUFDSCxNQUFhLGFBQWE7SUFDeEI7OztPQUdHO0lBQ0ksTUFBTSxDQUFDLGlCQUFpQixDQUFDLFFBQWdCO1FBQzlDLGlGQUFpRjtRQUNqRixNQUFNLEVBQUUsR0FBRyx1QkFBdUIsQ0FBQztRQUNuQyxJQUFJLE1BQU0sR0FBRyxRQUFRLENBQUM7UUFDdEIsSUFBSSxDQUFDLENBQUM7UUFDTixHQUFHO1lBQ0QsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDdEIsSUFBSSxDQUFDLEVBQUU7Z0JBQ0wsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsbUNBQW1DO2dCQUM1RSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxzREFBc0Q7Z0JBQ3hFLE1BQU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFH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Q0FBNkMsTUFBTSxHQUFHLENBQUMsQ0FBQztTQUN6RTtRQUVELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVPLGtCQUFrQixDQUFDLFFBQWdCLEVBQUUsU0FBc0I7UUFDakUsT0FBTyxLQUFLLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNwRixDQUFDO0lBRU8sVUFBVSxDQUFDLEdBQVc7UUFDNUIsS0FBSyxNQUFNLE9BQU8sSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2xDLE1BQU0sRUFBRSxHQUFHLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQy9CLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDaEIsT0FBTyxJQUFJLENBQUM7YUFDYjtTQUNGO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0NBRUY7QUFwZ0JELHNDQW9nQkM7QUFFRCxTQUFTLHdCQUF3QixDQUFDLElBQVM7SUFDekMsT0FBTyxJQUFJLElBQUksQ0FBQyxPQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssUUFBUSxJQUFJLGVBQWUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUMvRSxDQUFDO0FBRUQsU0FBUyxVQUFVLENBQUMsQ0FBUztJQUMzQixPQUFPLElBQUEsbUJBQVMsRUFBQyxDQUFDLEVBQUUsRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUM1QyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNhbWVsQ2FzZSBmcm9tICdjYW1lbGNhc2UnO1xuaW1wb3J0IHsgSlNPTlNjaGVtYTQgfSBmcm9tICdqc29uLXNjaGVtYSc7XG5pbXBvcnQgeyBzbmFrZUNhc2UgfSBmcm9tICdzbmFrZS1jYXNlJztcbmltcG9ydCB7IENvZGUgfSBmcm9tICcuL2NvZGUnO1xuaW1wb3J0IHsgVG9Kc29uRnVuY3Rpb24gfSBmcm9tICcuL3RvanNvbic7XG5cblxuY29uc3QgUFJJTUlUSVZFX1RZUEVTID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2ludGVnZXInLCAnYm9vbGVhbiddO1xuY29uc3QgREVGSU5JVElPTlNfUFJFRklYID0gJyMvZGVmaW5pdGlvbnMvJztcbmNvbnN0IERFRkFVTFRfUkVOREVSX1RZUEVfTkFNRSA9IChzOiBzdHJpbmcpID0+IHMuc3BsaXQoJy4nKS5tYXAoeCA9PiBwYXNjYWxDYXNlKHgpKS5qb2luKCcnKTtcblxuZXhwb3J0IGludGVyZmFjZSBUeXBlR2VuZXJhdG9yT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBQYXR0ZXJucyBvZiB0eXBlIEZRTnMgdG8gZXhjbHVkZS5cbiAgICogQGRlZmF1bHQgLSBpbmNsdWRlIGFsbCB0eXBlc1xuICAgKi9cbiAgcmVhZG9ubHkgZXhjbHVkZT86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBTY2hlbWEgZGVmaW5pdGlvbnMgZm9yIHJlc29sdmluZyAkcmVmc1xuICAgKiBAZGVmYXVsdCAtICRyZWZzIGFyZSBub3Qgc3VwcG9ydGVkXG4gICAqL1xuICByZWFkb25seSBkZWZpbml0aW9ucz86IHsgW2RlZjogc3RyaW5nXTogSlNPTlNjaGVtYTQgfTtcblxuICAvKipcbiAgICogR2VuZXJhdGUgYHRvSnNvbl9YeXpgIGZ1bmN0aW9ucyBmb3IgYWxsIHR5cGVzIHdoaWNoIGNvbnZlcnQgZGF0YSBvYmplY3RzXG4gICAqIGJhY2sgdG8gc2NoZW1hLWNvbXBhdGlibGUgSlNPTi5cbiAgICpcbiAgICogVGhlc2UgZnVuY3Rpb25zIGFyZSByZXF1aXJlZCBzaW5jZSBwcm9wZXJ0eSBuYW1lcyBpbiBnZW5lcmF0ZWQgc3RydWN0cyBhcmVcbiAgICogY2FtZWwgY2FzZWQgaW4gb3JkZXIgdG8gYmUgY29tcGF0aWJsZSB3aXRoIEpTSUksIGFuZCB0aGlzIGlzIGEgbG9zc3lcbiAgICogY29udmVyc2lvbiwgc28gdGhlIHRvSnNvbiBmdW5jdGlvbnMgYXJlIHJlcXVpcmVkIHRvIGNvbnZlcnQgdGhlIGRhdGEgYmFja1xuICAgKiB0byBhIHNjaGVtYS1jb21wYXRpYmxlIGRhdGEgb2JqZWN0cy5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgdG9Kc29uPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogR2l2ZW4gYSBkZWZpbml0aW9uIG5hbWUsIHJlbmRlciB0aGUgdHlwZSBuYW1lIHRvIGJlIGVtaXR0ZWQgYnkgdGhhdCBkZWZpbml0aW9uLlxuICAgKlxuICAgKiBXaGVuIGBlbWl0VHlwZWAgaXMgaW52b2tlZCwgdGhlIHR5cGUgbmFtZSB0byBiZSBlbWl0dGVkIGlzIHByb3ZpZGVkIGJ5IHRoZSBjYWxsZXIuXG4gICAqIEhvd2V2ZXIsIGZvciBjb21wbGV4IHR5cGVzIGNvbnRhaW5pbmcgcmVmZXJlbmNlcyB0byBvdGhlciB0eXBlcywgd2UgaW5mZXIgdGhlIHR5cGUgbmFtZSBvZiB0aGUgcmVmZXJlbmNlXG4gICAqIGJ5IGxvb2tpbmcgYXQgdGhlIGRlZmluaXRpb24gbmFtZSBvZiB0aGUgYCRyZWZgIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBwcm92aWRlcyBhIHdheSB0byBjb250cm9sIGhvdyB0aG9zZSBkZWZpbml0aW9uIG5hbWVzIHRyYW5zbGF0ZSBpbnRvIHR5cGUgbmFtZS5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGlmIGEgY29tcGxleCB0eXBlIHJlZmVyZW5jZXMgYSBuYW1lc3BhY2VkIGRlZmluaXRpb24gbGlrZSBgYXBpLmdyb3VwLkZvb2AsIHdlJ2QgbGlrZSB0byBjb250cm9sXG4gICAqIGhvdyB0byB0cmFuc2xhdGUgYGFwaS5ncm91cC5Gb29gLCB3aGljaCBpcyBhbiBpbGxlZ2FsIHR5cGVuYW1lLCBpbnRvIGEgbGVnYWwgb25lLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIE9ubHkgZG90IG5hbWVzcGFjaW5nIGlzIGhhbmRsZWQgYnkgZGVmYXVsdC4gRWxlbWVudHMgYmV0d2VlbiBkb3RzIGFyZSBwYXNjYWwgY2FzZWQgYW5kIGNvbmNhdGVuYXRlZC5cbiAgICovXG4gIHJlYWRvbmx5IHJlbmRlclR5cGVOYW1lPzogKGRlZjogc3RyaW5nKSA9PiBzdHJpbmc7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHR5cGVzY3JpcHQgdHlwZXMgZnJvbSBKU09OIHNjaGVtYXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBUeXBlR2VuZXJhdG9yIHtcbiAgLyoqXG4gICAqIENvbnZlcnQgYWxsLWNhcHMgYWNyb255bXMgKGUuZy4gXCJWUENcIiwgXCJGb29CQVJab29GSUdvb1wiKSB0byBwYXNjYWwgY2FzZVxuICAgKiAoZS5nLiBcIlZwY1wiLCBcIkZvb0Jhclpvb0ZpR29vXCIpLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBub3JtYWxpemVUeXBlTmFtZSh0eXBlTmFtZTogc3RyaW5nKSB7XG4gICAgLy8gc3RhcnQgd2l0aCB0aGUgZnVsbCBzdHJpbmcgYW5kIHRoZW4gdXNlIHRoZSByZWdleCB0byBtYXRjaCBhbGwtY2FwcyBzZXF1ZW5jZXMuXG4gICAgY29uc3QgcmUgPSAvKFtBLVpdKykoPzpbXmEtel18JCkvZztcbiAgICBsZXQgcmVzdWx0ID0gdHlwZU5hbWU7XG4gICAgbGV0IG07XG4gICAgZG8ge1xuICAgICAgbSA9IHJlLmV4ZWModHlwZU5hbWUpO1xuICAgICAgaWYgKG0pIHtcbiAgICAgICAgY29uc3QgYmVmb3JlID0gcmVzdWx0LnNsaWNlKDAsIG0uaW5kZXgpOyAvLyBhbGwgdGhlIHRleHQgYmVmb3JlIHRoZSBzZXF1ZW5jZVxuICAgICAgICBjb25zdCBjYXAgPSBtWzFdOyAvLyBncm91cCAjMSBtYXRjaGVzIHRoZSBhbGwtY2FwcyBzZXF1ZW5jZSB3ZSBhcmUgYWZ0ZXJcbiAgICAgICAgY29uc3QgcGFzY2FsID0gY2FwWzBdICsgY2FwLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7IC8vIGNvbnZlcnQgdG8gcGFzY2FsIGNhc2UgYnkgbG93ZXJjYXNpbmcgYWxsIGJ1dCB0aGUgZmlyc3QgY2hhclxuICAgICAgICBjb25zdCBhZnRlciA9IHJlc3VsdC5zbGljZShtLmluZGV4ICsgcGFzY2FsLmxlbmd0aCk7IC8vIGFsbCB0aGUgdGV4dCBhZnRlciB0aGUgc2VxdWVuY2VcbiAgICAgICAgcmVzdWx0ID0gYmVmb3JlICsgcGFzY2FsICsgYWZ0ZXI7IC8vIGNvbmNhdFxuICAgICAgfVxuICAgIH0gd2hpbGUgKG0pO1xuXG4gICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL14uLywgcmVzdWx0WzBdLnRvVXBwZXJDYXNlKCkpOyAvLyBlbnN1cmUgZmlyc3QgbGV0dGVyIGlzIGNhcGl0YWxpemVkXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgSlNJSSBzdHJ1Y3QgKGFuZCBhY2NvbXBhbnlpbmcgdHlwZXMpIGZyb20gYSBKU09OIHNjaGVtYS5cbiAgICpcbiAgICogSWYgeW91IHdpc2ggdG8gcmVuZGVyIG11bHRpcGxlIHRvcC1sZXZlbCBzdHJ1Y3RzIG9yIGluY2x1ZGUgY3VzdG9tIHR5cGVzLFxuICAgKiBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYFR5cGVHZW5lcmF0b3JgIG1hbnVhbGx5LlxuICAgKlxuICAgKiBAcGFyYW0gc3RydWN0TmFtZSBUaGUgbmFtZSBvZiB0aGUgSlNJSSBzdHJ1Y3QgKFR5cGVTY3JpcHQgaW50ZXJmYWNlKS5cbiAgICogQHBhcmFtIHNjaGVtYSBUaGUgSlNPTiBzY2hlbWEgKHRvcCBsZXZlbCBzY2hlbWEgbXVzdCBpbmNsdWRlIFwicHJvcGVydGllc1wiKVxuICAgKiBAcmV0dXJucyBHZW5lcmF0ZWQgVHlwZVNjcmlwdCBzb3VyY2UgY29kZSB0aGF0IGluY2x1ZGVzIHRoZSB0b3AtbGV2ZWxcbiAgICogc3RydWN0IGFuZCBhbGwgb3RoZXIgdHlwZXMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZvclN0cnVjdChzdHJ1Y3ROYW1lOiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYTQsIG9wdGlvbnM6IFR5cGVHZW5lcmF0b3JPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBnZW4gPSBuZXcgVHlwZUdlbmVyYXRvcih7IGRlZmluaXRpb25zOiBzY2hlbWEuZGVmaW5pdGlvbnMsIC4uLm9wdGlvbnMgfSk7XG4gICAgZ2VuLmVtaXRUeXBlKHN0cnVjdE5hbWUsIHNjaGVtYSk7XG4gICAgcmV0dXJuIGdlbjtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZG9ubHkgdHlwZXNUb0VtaXQ6IHsgW25hbWU6IHN0cmluZ106IFR5cGVFbWl0dGVyIH0gPSB7IH07XG4gIHByaXZhdGUgcmVhZG9ubHkgZW1pdHRlZFR5cGVzOiBSZWNvcmQ8c3RyaW5nLCBFbWl0dGVkVHlwZT4gPSB7fTtcbiAgcHJpdmF0ZSByZWFkb25seSBleGNsdWRlOiBzdHJpbmdbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBkZWZpbml0aW9uczogeyBbZGVmOiBzdHJpbmddOiBKU09OU2NoZW1hNCB9O1xuICBwcml2YXRlIHJlYWRvbmx5IHRvSnNvbjogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSByZW5kZXJUeXBlTmFtZTogKGRlZjogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBzY2hlbWEgU2NoZW1hIGRlZmluaXRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBUeXBlR2VuZXJhdG9yT3B0aW9ucyA9IHsgfSkge1xuICAgIHRoaXMuZXhjbHVkZSA9IG9wdGlvbnMuZXhjbHVkZSA/PyBbXTtcbiAgICB0aGlzLmRlZmluaXRpb25zID0ge307XG4gICAgdGhpcy50b0pzb24gPSBvcHRpb25zLnRvSnNvbiA/PyB0cnVlO1xuICAgIHRoaXMucmVuZGVyVHlwZU5hbWUgPSBvcHRpb25zLnJlbmRlclR5cGVOYW1lID8/IERFRkFVTFRfUkVOREVSX1RZUEVfTkFNRTtcblxuICAgIGZvciAoY29uc3QgW3R5cGVOYW1lLCBkZWZdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuZGVmaW5pdGlvbnMgPz8ge30pKSB7XG4gICAgICB0aGlzLmFkZERlZmluaXRpb24odHlwZU5hbWUsIGRlZik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBKU09OIHNjaGVtYSBkZWZpbml0aW9uIGZvciBhIHR5cGUgbmFtZS4gVGhpcyBtZXRob2QgZG9lcyBub3QgZW1pdCB0aGUgdHlwZVxuICAgKiBidXQgcmF0aGVyIGp1c3QgcmVnaXN0ZXJzIHRoZSBkZWZpbml0aW9uIHRoYXQgd2lsbCBnZXQgcmVzb2x2ZWQgaWYgdGhpcyB0eXBlIGlzIGAkcmVmYGVkLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZU5hbWUgVGhlIG5hbWUgb2YgdGhlIHR5cGUuXG4gICAqIEBwYXJhbSBkZWYgVGhlIEpTT04gc2NoZW1hIGRlZmluaXRpb24gZm9yIHRoaXMgdHlwZVxuICAgKi9cbiAgcHVibGljIGFkZERlZmluaXRpb24odHlwZU5hbWU6IHN0cmluZywgZGVmOiBKU09OU2NoZW1hNCkge1xuICAgIHRoaXMuZGVmaW5pdGlvbnNbdHlwZU5hbWVdID0gZGVmO1xuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyB0aGUgZGVmaW5pdGlvbiBvZiBgZnJvbVR5cGVOYW1lYCBzdWNoIHRoYXQgYW55IHJlZmVyZW5jZXMgdG8gaXRcbiAgICogd2lsbCBiZSByZXNvbHZlZCBhcyBgdG9UeXBlTmFtZWAuIEJlYXIgaW4gbWluZCB0aGF0IHRoZSB0eXBlIG5hbWUgc3BlY2lmaWVkXG4gICAqIGluIGB0b2AgbXVzdCBlaXRoZXIgYmUgZGVmaW5lZCBhcyBhIGRlZmluaXRpb24gKGBhZGREZWZpbml0aW9uKClgKSBfb3JfXG4gICAqIGVtaXR0ZWQgYXMgYSBjdXN0b20gdHlwZSAoYGVtaXRDdXN0b21UeXBlKClgKS5cbiAgICovXG4gIHB1YmxpYyBhZGRBbGlhcyhmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcpIHtcbiAgICB0aGlzLmFkZERlZmluaXRpb24oZnJvbSwgeyAkcmVmOiBgIy9kZWZpbml0aW9ucy8ke3RvfWAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCBhIHR5cGUgYmFzZWQgb24gYSBKU09OIHNjaGVtYS4gSWYgYGRlZmAgaXMgbm90IHNwZWNpZmllZCwgdGhlXG4gICAqIGRlZmluaXRpb24gb2YgdGhlIHR5cGUgd2lsbCBiZSBsb29rZWQgdXAgaW4gdGhlIGBkZWZpbml0aW9uc2AgcHJvdmlkZWRcbiAgICogZHVyaW5nIGluaXRpYWxpemF0aW9uIG9yIHZpYSBgYWRkRGVmaW5pdGlvbigpYC5cbiAgICpcbiAgICogQHBhcmFtIHR5cGVOYW1lIFRoZSBuYW1lIG9mIHRoIHR5cGVcbiAgICogQHBhcmFtIGRlZiBKU09OIHNjaGVtYS4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHNjaGVtYSBpcyBsb29rZWQgdXAgZnJvbVxuICAgKiBgZGVmaW5pdGlvbnNgIGJhc2VkIG9uIHRoZSB0eXBlIG5hbWVcbiAgICogQHBhcmFtIHN0cnVjdEZxbiBGUU4gZm9yIHRoZSB0eXBlIChkZWZhdWx0cyB0byBgdHlwZU5hbWVgKVxuICAgKiBAcmV0dXJucyBUaGUgcmVzb2x2ZWQgdHlwZSAobm90IGFsd2F5cyB0aGUgc2FtZSBhcyBgdHlwZU5hbWVgKVxuICAgKi9cbiAgcHVibGljIGVtaXRUeXBlKHR5cGVOYW1lOiBzdHJpbmcsIGRlZj86IEpTT05TY2hlbWE0LCBzdHJ1Y3RGcW46IHN0cmluZyA9IHR5cGVOYW1lKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0VHlwZUludGVybmFsKHR5cGVOYW1lLCBkZWYsIHN0cnVjdEZxbikudHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGEgdHlwZSBiYXNlZCBvbiBhIEpTT04gc2NoZW1hLiBJZiBgZGVmYCBpcyBub3Qgc3BlY2lmaWVkLCB0aGVcbiAgICogZGVmaW5pdGlvbiBvZiB0aGUgdHlwZSB3aWxsIGJlIGxvb2tlZCB1cCBpbiB0aGUgYGRlZmluaXRpb25zYCBwcm92aWRlZFxuICAgKiBkdXJpbmcgaW5pdGlhbGl6YXRpb24gb3IgdmlhIGBhZGREZWZpbml0aW9uKClgLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZU5hbWUgVGhlIG5hbWUgb2YgdGggdHlwZVxuICAgKiBAcGFyYW0gZGVmIEpTT04gc2NoZW1hLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgc2NoZW1hIGlzIGxvb2tlZCB1cCBmcm9tXG4gICAqIGBkZWZpbml0aW9uc2AgYmFzZWQgb24gdGhlIHR5cGUgbmFtZVxuICAgKiBAcGFyYW0gc3RydWN0RnFuIEZRTiBmb3IgdGhlIHR5cGUgKGRlZmF1bHRzIHRvIGB0eXBlTmFtZWApXG4gICAqIEByZXR1cm5zIFRoZSByZXNvbHZlZCB0eXBlIChub3QgYWx3YXlzIHRoZSBzYW1lIGFzIGB0eXBlTmFtZWApXG4gICAqL1xuICBwcml2YXRlIGVtaXRUeXBlSW50ZXJuYWwodHlwZU5hbWU6IHN0cmluZywgZGVmPzogSlNPTlNjaGVtYTQsIHN0cnVjdEZxbjogc3RyaW5nID0gdHlwZU5hbWUpOiBFbWl0dGVkVHlwZSB7XG4gICAgaWYgKCFkZWYpIHtcbiAgICAgIGRlZiA9IHRoaXMuZGVmaW5pdGlvbnNbdHlwZU5hbWVdO1xuICAgICAgaWYgKCFkZWYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmFibGUgdG8gZmluZCBzY2hlbWEgZGVmaW5pdGlvbiBmb3IgJHt0eXBlTmFtZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxsZXJzIGV4cGVjdCB0aGF0IGVtaXQgYSB0eXBlIG5hbWVkIGB0eXBlTmFtZWAgc28gd2UgY2FuJ3QgY2hhbmdlIGl0IGhlcmVcbiAgICAvLyBidXQgYXQgbGVhc3Qgd2UgY2FuIHZlcmlmeSBpdCdzIGNvcnJlY3QuXG4gICAgaWYgKFR5cGVHZW5lcmF0b3Iubm9ybWFsaXplVHlwZU5hbWUodHlwZU5hbWUpICE9PSB0eXBlTmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3R5cGVOYW1lfSBtdXN0IGJlIG5vcm1hbGl6ZWQgYmVmb3JlIGNhbGxpbmcgZW1pdFR5cGVgKTtcbiAgICB9XG5cbiAgICBpZiAoc3RydWN0RnFuLnN0YXJ0c1dpdGgoREVGSU5JVElPTlNfUFJFRklYKSkge1xuICAgICAgc3RydWN0RnFuID0gc3RydWN0RnFuLnN1YnN0cmluZyhERUZJTklUSU9OU19QUkVGSVgubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0V4Y2x1ZGVkKHN0cnVjdEZxbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHlwZSAke3N0cnVjdEZxbn0gY2Fubm90IGJlIGFkZGVkIHNpbmNlIGl0IG1hdGNoZXMgb25lIG9mIHRoZSBleGNsdXNpb24gcGF0dGVybnNgKTtcbiAgICB9XG5cbiAgICAvLyBjb21wbGV4IHR5cGVcbiAgICBpZiAoZGVmLiRyZWYpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGVGb3JSZWYoZGVmKTtcbiAgICB9XG5cbiAgICAvLyB1bmlvbnMgKHVubGVzcyB0aGlzIGlzIGEgc3RydWN0LCBhbmQgdGhlbiB3ZSBqdXN0IGlnbm9yZSB0aGUgY29uc3RyYWludHMpXG4gICAgaWYgKGRlZi5vbmVPZiB8fCBkZWYuYW55T2YpIHtcblxuICAgICAgY29uc3QgYXNVbmlvbiA9IHRoaXMudHJ5RW1pdFVuaW9uKHR5cGVOYW1lLCBkZWYsIHN0cnVjdEZxbik7XG4gICAgICBpZiAoYXNVbmlvbikge1xuICAgICAgICByZXR1cm4gYXNVbmlvbjtcbiAgICAgIH1cblxuICAgICAgLy8gY2Fycnkgb24sIHdlIGNhbid0IHJlcHJlc2VudCB0aGlzIHNjaGVtYSBhcyBhIHVuaW9uICh5ZXQ/KVxuICAgIH1cblxuICAgIC8vIGRhdGVzXG4gICAgaWYgKGRlZi5mb3JtYXQgPT09ICdkYXRlLXRpbWUnKSB7XG4gICAgICBpZiAoZGVmLnR5cGUgJiYgZGVmLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGF0ZS10aW1lIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgdHlwZTogJ0RhdGUnLCB0b0pzb246IHggPT4gYCR7eH0/LnRvSVNPU3RyaW5nKClgIH07XG4gICAgfVxuXG4gICAgLy8gZW51bXNcbiAgICBpZiAoZGVmLmVudW0gJiYgQXJyYXkuaXNBcnJheShkZWYuZW51bSkgJiYgZGVmLmVudW0ubGVuZ3RoID4gMCAmJiBkZWYuZW51bS5ldmVyeSh4ID0+IFsnc3RyaW5nJywgJ251bWJlciddLmluY2x1ZGVzKHR5cGVvZih4KSkpKSB7XG4gICAgICBpZiAoZGVmLnR5cGUgJiYgIShkZWYudHlwZSA9PT0gJ3N0cmluZycgfHwgZGVmLnR5cGUgPT09ICdudW1iZXInIHx8IGRlZi50eXBlID09PSAnaW50ZWdlcicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb25seSBlbnVtcyB3aXRoIHN0cmluZyBvciBudW1iZXIgdmFsdWVzIGFyZSBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZW1pdEVudW0odHlwZU5hbWUsIGRlZiwgc3RydWN0RnFuKTtcbiAgICB9XG5cbiAgICAvLyBzdHJ1Y3RcbiAgICBpZiAoZGVmLnByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChkZWYudHlwZSAmJiBkZWYudHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmb3IgXCJwcm9wZXJ0aWVzXCIsIGlmIFwidHlwZVwiIGlzIHNwZWNpZmllZCBpdCBoYXMgdG8gYmUgYW4gXCJvYmplY3RcIicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lbWl0U3RydWN0KHR5cGVOYW1lLCBkZWYsIHN0cnVjdEZxbik7XG4gICAgfVxuXG4gICAgLy8gbWFwXG4gICAgaWYgKGRlZi5hZGRpdGlvbmFsUHJvcGVydGllcyAmJiB0eXBlb2YoZGVmLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChkZWYudHlwZSAmJiBkZWYudHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmb3IgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLCBpZiBcInR5cGVcIiBpcyBzcGVjaWZpZWQgaXQgaGFzIHRvIGJlIGFuIFwib2JqZWN0XCInKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXQgPSB0aGlzLnR5cGVGb3JQcm9wZXJ0eSh0eXBlTmFtZSwgZGVmLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKTtcbiAgICAgIGNvbnN0IHRvSnNvbiA9ICh4OiBzdHJpbmcpID0+IGAoKCR7eH0pID09PSB1bmRlZmluZWQpID8gdW5kZWZpbmVkIDogKE9iamVjdC5lbnRyaWVzKCR7eH0pLnJlZHVjZSgociwgaSkgPT4gKGlbMV0gPT09IHVuZGVmaW5lZCkgPyByIDogKHsgLi4uciwgW2lbMF1dOiAke2V0LnRvSnNvbignaVsxXScpIH0gfSksIHt9KSlgO1xuICAgICAgcmV0dXJuIHsgdHlwZTogYHsgW2tleTogc3RyaW5nXTogJHtldC50eXBlfSB9YCwgdG9Kc29uIH07XG4gICAgfVxuXG4gICAgc3dpdGNoIChkZWYudHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ3N0cmluZycsIHRvSnNvbjogeCA9PiB4IH07XG5cbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ251bWJlcicsIHRvSnNvbjogeCA9PiB4IH07XG5cbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4geyB0eXBlOiAnYm9vbGVhbicsIHRvSnNvbjogKHgpID0+IHggfTtcblxuICAgICAgY2FzZSAnYXJyYXknOiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXRBcnJheSh0eXBlTmFtZSwgZGVmKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyB0eXBlOiAnYW55JywgdG9Kc29uOiB4ID0+IHggfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBjdXN0b20gdHlwZSBhbmQgZW1pdHMgaXQuIFRoaXMgd2lsbCBvdmVycmlkZSBhbnkgZXhpc3RpbmdcbiAgICogZGVmaW5pdGlvbnMgZm9yIHRoaXMgdHlwZSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZU5hbWUgVGhlIG5hbWUgb2YgdGhlIHR5cGUgZW1pdHRlZCBieSB0aGlzIGhhbmRsZXIuXG4gICAqIEBwYXJhbSBlbWl0dGVyIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB0byBlbWl0IHRoZSBjb2RlIGFuZCByZXR1cm5zXG4gICAqIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlbWl0dGVkIHR5cGUuXG4gICAqL1xuICBwdWJsaWMgZW1pdEN1c3RvbVR5cGUodHlwZU5hbWU6IHN0cmluZywgZW1pdHRlcjogVHlwZUVtaXR0ZXIgfCBDb2RlRW1pdHRlcikge1xuICAgIGlmICh0eXBlTmFtZSBpbiB0aGlzLmVtaXR0ZWRUeXBlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudHlwZXNUb0VtaXRbdHlwZU5hbWVdID0gY29kZSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBlbWl0dGVyKGNvZGUpO1xuICAgICAgaWYgKHR5cGVvZihyZXN1bHQpID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogdHlwZU5hbWUsIHRvSnNvbjogeCA9PiB4IH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGVtaXRDdXN0b21UeXBlKClgXG4gICAqL1xuICBwdWJsaWMgYWRkQ29kZSh0eXBlTmFtZTogc3RyaW5nLCBlbWl0dGVyOiBUeXBlRW1pdHRlciB8IENvZGVFbWl0dGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdEN1c3RvbVR5cGUodHlwZU5hbWUsIGVtaXR0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYWxsIGVtaXR0ZWQgdHlwZXMgdG8gYSBzdHJpbmcuXG4gICAqXG4gICAqIFVzZSBgcmVuZGVyVG9Db2RlKClgIGluIG9yZGVyIHRvIHJlbmRlciBvdXRwdXQgdG8gYW4gZXhpc3RpbmcgYENvZGVgIG9iamVjdC5cbiAgICovXG4gIHB1YmxpYyByZW5kZXIoKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb2RlID0gbmV3IENvZGUoKTtcbiAgICB0aGlzLnJlbmRlclRvQ29kZShjb2RlKTtcbiAgICByZXR1cm4gY29kZS5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgYWxsIHR5cGVzIHRvIGEgYENvZGVNYWtlcmAgd2l0aCBhbiBvcGVuIGZpbGUuXG4gICAqIFVzZSB0aGlzIG1ldGhvZCBpbiBjYXNlIHlvdSBuZWVkIHRvIGFkZCB0aG9zZSB0eXBlIHRvIGFuIGV4aXN0aW5nIGZpbGUuXG4gICAqIEBwYXJhbSBjb2RlIFRoZSBgQ29kZU1ha2VyYCBpbnN0YW5jZS5cbiAgICovXG4gIHB1YmxpYyByZW5kZXJUb0NvZGUoY29kZTogQ29kZSkge1xuICAgIHdoaWxlIChPYmplY3Qua2V5cyh0aGlzLnR5cGVzVG9FbWl0KS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBPYmplY3Qua2V5cyh0aGlzLnR5cGVzVG9FbWl0KVswXTtcbiAgICAgIGNvbnN0IGVtaXR0ZXIgPSB0aGlzLnR5cGVzVG9FbWl0W25hbWVdO1xuICAgICAgY29uc3QgZW1pdHRlZFR5cGUgPSBlbWl0dGVyKGNvZGUpO1xuICAgICAgY29kZS5saW5lKCk7XG4gICAgICBkZWxldGUgdGhpcy50eXBlc1RvRW1pdFtuYW1lXTtcbiAgICAgIHRoaXMuZW1pdHRlZFR5cGVzW25hbWVdID0gZW1pdHRlZFR5cGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgcmVuZGVyVG9Db2RlKClgXG4gICAqL1xuICBwdWJsaWMgZW1pdENvZGUoY29kZTogQ29kZSkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRvQ29kZShjb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGVtaXRUeXBlKClgXG4gICAqL1xuICBwdWJsaWMgYWRkVHlwZSh0eXBlTmFtZTogc3RyaW5nLCBkZWY/OiBKU09OU2NoZW1hNCwgc3RydWN0RnFuOiBzdHJpbmcgPSB0eXBlTmFtZSkge1xuICAgIHJldHVybiB0aGlzLmVtaXRUeXBlKHR5cGVOYW1lLCBkZWYsIHN0cnVjdEZxbik7XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgYW4gYXJyYXkuXG4gICAqL1xuICBwcml2YXRlIGVtaXRBcnJheSh0eXBlTmFtZTogc3RyaW5nLCBkZWY6IEpTT05TY2hlbWE0KTogRW1pdHRlZFR5cGUge1xuICAgIGNvbnN0IGV0ID0gdGhpcy50eXBlRm9yQXJyYXkodHlwZU5hbWUsIGRlZik7XG4gICAgcmV0dXJuIHsgdHlwZTogYCR7ZXQudHlwZX1bXWAsIHRvSnNvbjogeCA9PiBgJHt4fT8ubWFwKHkgPT4gJHtldC50b0pzb24oJ3knKX0pYCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBkZWZpbml0aW9uIGNhbiBiZSByZXByZXNlbnRlZCBhcyBhIHVuaW9uIG9yIGZhbHNlIGlmIGl0IGNhbm5vdFxuICAgKi9cbiAgcHJpdmF0ZSB0cnlFbWl0VW5pb24odHlwZU5hbWU6IHN0cmluZywgZGVmOiBKU09OU2NoZW1hNCwgZnFuOiBzdHJpbmcpOiBFbWl0dGVkVHlwZSB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gICAgZm9yIChjb25zdCBvcHRpb24gb2YgZGVmLm9uZU9mIHx8IGRlZi5hbnlPZiB8fCBbXSkge1xuICAgICAgaWYgKCFzdXBwb3J0ZWRVbmlvbk9wdGlvblR5cGUob3B0aW9uLnR5cGUpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR5cGUgPSBvcHRpb24udHlwZSA9PT0gJ2ludGVnZXInID8gJ251bWJlcicgOiBvcHRpb24udHlwZTtcbiAgICAgIG9wdGlvbnMucHVzaCh0eXBlKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbWl0dGVkOiBFbWl0dGVkVHlwZSA9IHsgdHlwZTogdHlwZU5hbWUsIHRvSnNvbjogeCA9PiBgJHt4fT8udmFsdWVgIH07XG5cbiAgICB0aGlzLmFkZENvZGUodHlwZU5hbWUsIGNvZGUgPT4ge1xuICAgICAgdGhpcy5lbWl0RGVzY3JpcHRpb24oY29kZSwgZnFuLCBkZWYuZGVzY3JpcHRpb24pO1xuXG4gICAgICBjb2RlLm9wZW5CbG9jayhgZXhwb3J0IGNsYXNzICR7dHlwZU5hbWV9YCk7XG4gICAgICBjb25zdCBwb3NzaWJsZVR5cGVzID0gW107XG5cbiAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBvcHRpb25zKSB7XG4gICAgICAgIHBvc3NpYmxlVHlwZXMucHVzaCh0eXBlKTtcbiAgICAgICAgY29uc3QgbWV0aG9kTmFtZSA9ICdmcm9tJyArIHR5cGVbMF0udG9VcHBlckNhc2UoKSArIHR5cGUuc3Vic3RyKDEpO1xuICAgICAgICBjb2RlLm9wZW5CbG9jayhgcHVibGljIHN0YXRpYyAke21ldGhvZE5hbWV9KHZhbHVlOiAke3R5cGV9KTogJHt0eXBlTmFtZX1gKTtcbiAgICAgICAgY29kZS5saW5lKGByZXR1cm4gbmV3ICR7dHlwZU5hbWV9KHZhbHVlKTtgKTtcbiAgICAgICAgY29kZS5jbG9zZUJsb2NrKCk7XG4gICAgICB9XG5cbiAgICAgIGNvZGUub3BlbkJsb2NrKGBwcml2YXRlIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSB2YWx1ZTogJHtwb3NzaWJsZVR5cGVzLmpvaW4oJyB8ICcpfSlgKTtcbiAgICAgIGNvZGUuY2xvc2VCbG9jaygpO1xuXG4gICAgICBjb2RlLmNsb3NlQmxvY2soKTtcblxuICAgICAgcmV0dXJuIGVtaXR0ZWQ7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZW1pdHRlZDtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdFN0cnVjdCh0eXBlTmFtZTogc3RyaW5nLCBzdHJ1Y3REZWY6IEpTT05TY2hlbWE0LCBzdHJ1Y3RGcW46IHN0cmluZyk6IEVtaXR0ZWRUeXBlIHtcbiAgICBjb25zdCB0b0pzb24gPSBuZXcgVG9Kc29uRnVuY3Rpb24odHlwZU5hbWUpO1xuICAgIGNvbnN0IGVtaXR0ZWQ6IEVtaXR0ZWRUeXBlID0ge1xuICAgICAgdHlwZTogdHlwZU5hbWUsXG4gICAgICB0b0pzb246IHggPT4gYCR7dG9Kc29uLmZ1bmN0aW9uTmFtZX0oJHt4fSlgLFxuICAgIH07XG5cbiAgICB0aGlzLmVtaXRDdXN0b21UeXBlKHR5cGVOYW1lLCBjb2RlID0+IHtcblxuICAgICAgdGhpcy5lbWl0RGVzY3JpcHRpb24oY29kZSwgc3RydWN0RnFuLCBzdHJ1Y3REZWYuZGVzY3JpcHRpb24pO1xuICAgICAgY29kZS5vcGVuQmxvY2soYGV4cG9ydCBpbnRlcmZhY2UgJHt0eXBlTmFtZX1gKTtcblxuICAgICAgZm9yIChjb25zdCBbcHJvcE5hbWUsIHByb3BTcGVjXSBvZiBPYmplY3QuZW50cmllcyhzdHJ1Y3REZWYucHJvcGVydGllcyB8fCB7fSkpIHtcbiAgICAgICAgdGhpcy5lbWl0UHJvcGVydHkoY29kZSwgcHJvcE5hbWUsIHByb3BTcGVjLCBzdHJ1Y3RGcW4sIHN0cnVjdERlZiwgdG9Kc29uKTtcbiAgICAgIH1cblxuICAgICAgY29kZS5jbG9zZUJsb2NrKCk7XG5cbiAgICAgIGlmICh0aGlzLnRvSnNvbikge1xuICAgICAgICB0b0pzb24uZW1pdChjb2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVtaXR0ZWQ7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZW1pdHRlZDtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdFByb3BlcnR5KGNvZGU6IENvZGUsIG5hbWU6IHN0cmluZywgcHJvcERlZjogSlNPTlNjaGVtYTQsIHN0cnVjdEZxbjogc3RyaW5nLCBzdHJ1Y3REZWY6IEpTT05TY2hlbWE0LCB0b0pzb246IFRvSnNvbkZ1bmN0aW9uKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxOYW1lID0gbmFtZTtcblxuICAgIC8vIGlmIHRoZSBuYW1lIHN0YXJ0cyB3aXRoICckJyAobGlrZSAkcmVmIG9yICRzY2hlbWEpLCB3ZSByZW1vdmUgdGhlIFwiJFwiXG4gICAgLy8gYW5kIGl0J3MgdGhlIHNhbWUgZGVhbCAtIHdpbGwgcHJvZHVjZSBpbnZhbGlkIG91dHB1dFxuICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJyQnKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgdGhlIG5hbWUgdG8gY2FtZWwgY2FzZSBzbyBpdCdzIGNvbXBhdGlibGUgd2l0aCBKU0lJXG4gICAgbmFtZSA9IGNhbWVsQ2FzZShuYW1lKTtcblxuICAgIHRoaXMuZW1pdERlc2NyaXB0aW9uKGNvZGUsIGAke3N0cnVjdEZxbn0jJHtvcmlnaW5hbE5hbWV9YCwgcHJvcERlZi5kZXNjcmlwdGlvbik7XG4gICAgY29uc3QgcHJvcGVydHlUeXBlID0gdGhpcy50eXBlRm9yUHJvcGVydHkoYCR7c3RydWN0RnFufS4ke25hbWV9YCwgcHJvcERlZik7XG4gICAgY29uc3QgcmVxdWlyZWQgPSB0aGlzLmlzUHJvcGVydHlSZXF1aXJlZChvcmlnaW5hbE5hbWUsIHN0cnVjdERlZik7XG4gICAgY29uc3Qgb3B0aW9uYWwgPSByZXF1aXJlZCA/ICcnIDogJz8nO1xuXG4gICAgY29kZS5saW5lKGByZWFkb25seSAke25hbWV9JHtvcHRpb25hbH06ICR7cHJvcGVydHlUeXBlLnR5cGV9O2ApO1xuICAgIGNvZGUubGluZSgpO1xuXG4gICAgdG9Kc29uLmFkZEZpZWxkKG9yaWdpbmFsTmFtZSwgbmFtZSwgcHJvcGVydHlUeXBlLnRvSnNvbik7XG4gIH1cblxuICBwcml2YXRlIGVtaXRFbnVtKHR5cGVOYW1lOiBzdHJpbmcsIGRlZjogSlNPTlNjaGVtYTQsIHN0cnVjdEZxbjogc3RyaW5nKTogRW1pdHRlZFR5cGUge1xuICAgIGNvbnN0IGVtaXR0ZWQ6IEVtaXR0ZWRUeXBlID0ge1xuICAgICAgdHlwZTogdHlwZU5hbWUsXG4gICAgICB0b0pzb246IHggPT4geCxcbiAgICB9O1xuXG4gICAgdGhpcy5lbWl0Q3VzdG9tVHlwZSh0eXBlTmFtZSwgY29kZSA9PiB7XG5cbiAgICAgIGlmICghZGVmLmVudW0gfHwgZGVmLmVudW0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGVmaW5pdGlvbiBpcyBub3QgYW4gZW51bTogJHtKU09OLnN0cmluZ2lmeShkZWYpfWApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmLnR5cGUgJiYgIShkZWYudHlwZSA9PT0gJ3N0cmluZycgfHwgZGVmLnR5cGUgPT09ICdudW1iZXInIHx8IGRlZi50eXBlID09PSAnaW50ZWdlcicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb25seSBlbnVtcyB3aXRoIHN0cmluZyBvciBudW1iZXIgdmFsdWVzIGFyZSBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWl0RGVzY3JpcHRpb24oY29kZSwgc3RydWN0RnFuLCBkZWYuZGVzY3JpcHRpb24pO1xuXG4gICAgICBjb2RlLm9wZW5CbG9jayhgZXhwb3J0IGVudW0gJHt0eXBlTmFtZX1gKTtcblxuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkZWYuZW51bSkge1xuICAgICAgICBpZiAoIVsnc3RyaW5nJywgJ251bWJlciddLmluY2x1ZGVzKHR5cGVvZih2YWx1ZSkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmx5IGVudW1zIHdpdGggc3RyaW5nIG9yIG51bWJlciB2YWx1ZXMgYXJlIHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2x1Z2dpZnkgYW5kIHR1cm4gdG8gVVBQRVJfU05BS0VfQ0FTRVxuICAgICAgICBsZXQgbWVtYmVyTmFtZSA9IHNuYWtlQ2FzZShgJHt2YWx1ZX1gLnJlcGxhY2UoL1teYS16MC05XS9naSwgJ18nKSkuc3BsaXQoJ18nKS5maWx0ZXIoeCA9PiB4KS5qb2luKCdfJykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAvLyBpZiBtZW1iZXIgbmFtZSBzdGFydHMgd2l0aCBhIG5vbi1hbHBoYSBjaGFyYWN0ZXIsIGFkZCBhIHByZWZpeCBzbyBpdCBiZWNvbWVzIGEgc3ltYm9sXG4gICAgICAgIGlmICghL15bQS1aXS4qL2kudGVzdChtZW1iZXJOYW1lKSkge1xuICAgICAgICAgIG1lbWJlck5hbWUgPSAnVkFMVUVfJyArIG1lbWJlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlLmxpbmUoYC8qKiAke3ZhbHVlfSAqL2ApO1xuICAgICAgICBjb2RlLmxpbmUoYCR7bWVtYmVyTmFtZX0gPSAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0sYCk7XG4gICAgICB9XG5cbiAgICAgIGNvZGUuY2xvc2VCbG9jaygpO1xuXG4gICAgICByZXR1cm4gZW1pdHRlZDtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbWl0dGVkO1xuICB9XG5cbiAgcHJpdmF0ZSBlbWl0RGVzY3JpcHRpb24oY29kZTogQ29kZSwgZnFuOiBzdHJpbmcsIGRlc2NyaXB0aW9uPzogc3RyaW5nLCBhbm5vdGF0aW9uczogeyBbdHlwZTogc3RyaW5nXTogc3RyaW5nIH0gPSB7IH0pIHtcbiAgICBjb2RlLmxpbmUoJy8qKicpO1xuXG4gICAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgICBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uLnJlcGxhY2UoL1xcKlxcLy9nLCAnXy8nKTtcblxuICAgICAgZm9yIChjb25zdCBkbGluZSBvZiBkZXNjcmlwdGlvbi5zcGxpdCgnXFxuJykubWFwKHggPT4geC50cmltKCkpKSB7XG4gICAgICAgIGNvZGUubGluZShgICogJHtkbGluZX1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXh0cmFjdERlZmF1bHQgPSAvRGVmYXVsdHM/XFxXKyh0b3xpcylcXFcrKC4rKS9nLmV4ZWMoZGVzY3JpcHRpb24pO1xuICAgICAgY29uc3QgZGVmID0gZXh0cmFjdERlZmF1bHQgJiYgZXh0cmFjdERlZmF1bHRbMl07XG4gICAgICBpZiAoZGVmKSB7XG4gICAgICAgIGFubm90YXRpb25zLmRlZmF1bHQgPSBkZWY7XG4gICAgICB9XG5cbiAgICAgIGNvZGUubGluZSgnIConKTtcbiAgICB9XG5cbiAgICBhbm5vdGF0aW9ucy5zY2hlbWEgPSBmcW47XG5cbiAgICBmb3IgKGNvbnN0IFt0eXBlLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYW5ub3RhdGlvbnMpKSB7XG4gICAgICBjb2RlLmxpbmUoYCAqIEAke3R5cGV9ICR7dmFsdWV9YCk7XG4gICAgfVxuXG4gICAgY29kZS5saW5lKCcgKi8nKTtcbiAgfVxuXG4gIHByaXZhdGUgdHlwZUZvclByb3BlcnR5KHByb3BlcnR5RnFuOiBzdHJpbmcsIGRlZjogSlNPTlNjaGVtYTQpOiBFbWl0dGVkVHlwZSB7XG4gICAgY29uc3Qgc3VidHlwZSA9IFR5cGVHZW5lcmF0b3Iubm9ybWFsaXplVHlwZU5hbWUoREVGQVVMVF9SRU5ERVJfVFlQRV9OQU1FKHByb3BlcnR5RnFuKSk7XG4gICAgcmV0dXJuIHRoaXMuZW1pdFR5cGVJbnRlcm5hbChzdWJ0eXBlLCBkZWYsIHN1YnR5cGUpO1xuICB9XG5cbiAgcHJpdmF0ZSB0eXBlRm9yUmVmKGRlZjogSlNPTlNjaGVtYTQpOiBFbWl0dGVkVHlwZSB7XG4gICAgY29uc3QgcHJlZml4ID0gJyMvZGVmaW5pdGlvbnMvJztcbiAgICBpZiAoIWRlZi4kcmVmIHx8ICFkZWYuJHJlZi5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCAkcmVmICR7SlNPTi5zdHJpbmdpZnkoZGVmKX1gKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0V4Y2x1ZGVkKGRlZi4kcmVmKSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogJ2FueScsIHRvSnNvbjogeCA9PiB4IH07XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZU5hbWUgPSBUeXBlR2VuZXJhdG9yLm5vcm1hbGl6ZVR5cGVOYW1lKHRoaXMucmVuZGVyVHlwZU5hbWUoZGVmLiRyZWYuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpKSk7XG5cbiAgICAvLyBpZiB3ZSBhbHJlYWR5IGVtaXR0ZWQgYSB0eXBlIHdpdGggdGhpcyB0eXBlIG5hbWUsIGp1c3QgcmV0dXJuIGl0XG4gICAgY29uc3QgZW1pdHRlZCA9IHRoaXMuZW1pdHRlZFR5cGVzW3R5cGVOYW1lXTtcbiAgICBpZiAoZW1pdHRlZCkge1xuICAgICAgcmV0dXJuIGVtaXR0ZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NoZW1hID0gdGhpcy5yZXNvbHZlUmVmZXJlbmNlKGRlZik7XG4gICAgcmV0dXJuIHRoaXMuZW1pdFR5cGVJbnRlcm5hbCh0eXBlTmFtZSwgc2NoZW1hLCBkZWYuJHJlZik7XG4gIH1cblxuICBwcml2YXRlIHR5cGVGb3JBcnJheShwcm9wZXJ0eUZxbjogc3RyaW5nLCBkZWY6IEpTT05TY2hlbWE0KTogRW1pdHRlZFR5cGUge1xuICAgIGlmICghZGVmLml0ZW1zIHx8IHR5cGVvZihkZWYuaXRlbXMpICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBhcnJheSB0eXBlICR7ZGVmLml0ZW1zfWApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnR5cGVGb3JQcm9wZXJ0eShwcm9wZXJ0eUZxbiwgZGVmLml0ZW1zKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzb2x2ZVJlZmVyZW5jZShkZWY6IEpTT05TY2hlbWE0KTogSlNPTlNjaGVtYTQge1xuICAgIGNvbnN0IHJlZiA9IGRlZi4kcmVmO1xuICAgIGlmICghcmVmIHx8ICFyZWYuc3RhcnRzV2l0aChERUZJTklUSU9OU19QUkVGSVgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyBhIGxvY2FsIHJlZmVyZW5jZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGxvb2t1cCA9IHJlZi5zdWJzdHIoREVGSU5JVElPTlNfUFJFRklYLmxlbmd0aCk7XG4gICAgY29uc3QgZm91bmQgPSB0aGlzLmRlZmluaXRpb25zW2xvb2t1cF07XG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmFibGUgdG8gZmluZCBhIGRlZmluaXRpb24gZm9yIHRoZSAkcmVmIFwiJHtsb29rdXB9XCJgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cblxuICBwcml2YXRlIGlzUHJvcGVydHlSZXF1aXJlZChwcm9wZXJ0eTogc3RyaW5nLCBzdHJ1Y3REZWY6IEpTT05TY2hlbWE0KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3RydWN0RGVmLnJlcXVpcmVkKSAmJiBzdHJ1Y3REZWYucmVxdWlyZWQuaW5jbHVkZXMocHJvcGVydHkpO1xuICB9XG5cbiAgcHJpdmF0ZSBpc0V4Y2x1ZGVkKGZxbjogc3RyaW5nKSB7XG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHRoaXMuZXhjbHVkZSkge1xuICAgICAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xuICAgICAgaWYgKHJlLnRlc3QoZnFuKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBzdXBwb3J0ZWRVbmlvbk9wdGlvblR5cGUodHlwZTogYW55KTogdHlwZSBpcyBzdHJpbmcge1xuICByZXR1cm4gdHlwZSAmJiAodHlwZW9mKHR5cGUpID09PSAnc3RyaW5nJyAmJiBQUklNSVRJVkVfVFlQRVMuaW5jbHVkZXModHlwZSkpO1xufVxuXG5mdW5jdGlvbiBwYXNjYWxDYXNlKHM6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBjYW1lbENhc2UocywgeyBwYXNjYWxDYXNlOiB0cnVlIH0pO1xufVxuXG5pbnRlcmZhY2UgRW1pdHRlZFR5cGUge1xuICAvKipcbiAgICogVGhlIEphdmFTY3JpcHQgdHlwZSB0byBlbWl0LlxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb2RlIHRvIGNvbnZlcnQgYSBzdGF0ZW1lbnQgYHNgIGJhY2sgdG8gSlNPTi5cbiAgICovXG4gIHJlYWRvbmx5IHRvSnNvbjogKGNvZGU6IHN0cmluZykgPT4gc3RyaW5nO1xufVxuXG50eXBlIFR5cGVFbWl0dGVyID0gKGNvZGU6IENvZGUpID0+IEVtaXR0ZWRUeXBlO1xudHlwZSBDb2RlRW1pdHRlciA9IChjb2RlOiBDb2RlKSA9PiB2b2lkO1xuIl19